<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>REAL EXCAVATOR V48</title>
  <meta
    name="viewport"
    content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"
  />
  <style>
    body {
      margin: 0;
      background: #050505;
      overflow: hidden;
      font-family: "Noto Sans KR", system-ui, -apple-system, BlinkMacSystemFont,
        sans-serif;
    }
    #excavator-wrapper {
      position: relative;
      width: 100vw;
      height: 100vh;
      background: #050505;
      overflow: hidden;
    }
    #canvas-container {
      position: absolute;
      inset: 0;
    }
    #ui-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    /* ÏãúÏûë Ïò§Î≤ÑÎ†àÏù¥ */
    #start-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 10;
      color: #fff;
      pointer-events: auto;
    }
    #start-overlay h1 {
      color: #ffd700;
      font-size: 2.4rem;
      margin-bottom: 10px;
      text-shadow: 0 0 20px #ffd700;
      text-align: center;
    }
    #start-overlay p {
      margin-bottom: 20px;
      color: #ccc;
      text-align: center;
      font-size: 0.95rem;
    }
    #start-btn {
      padding: 14px 36px;
      font-size: 1.2rem;
      font-weight: 900;
      color: #111;
      background: linear-gradient(135deg, #ffd700 0%, #ffa500 100%);
      border: none;
      border-radius: 999px;
      cursor: pointer;
      box-shadow: 0 0 18px rgba(255, 165, 0, 0.6);
      text-transform: uppercase;
      letter-spacing: 2px;
    }
    #start-btn:active {
      transform: scale(0.96);
      box-shadow: 0 0 8px rgba(255, 215, 0, 0.7);
    }

    /* ÏÉÅÎã® ÏôºÏ™Ω Î≤ÑÌäºÎì§ */
    #top-left-buttons {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      gap: 6px;
      pointer-events: auto;
      flex-wrap: wrap;
      z-index: 5;
    }
    .top-btn {
      padding: 5px 10px;
      font-size: 0.7rem;
      border-radius: 999px;
      border: 1px solid #ffd700;
      background: rgba(0, 0, 0, 0.75);
      color: #ffd700;
      cursor: pointer;
      white-space: nowrap;
    }
    .top-btn:active {
      transform: scale(0.95);
      background: #ffd700;
      color: #000;
    }

    /* ÎØ∏ÏÖò Î∞ïÏä§ */
    #mission-box {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid #ffd700;
      border-radius: 12px;
      padding: 8px 18px;
      color: #fff;
      pointer-events: auto;
      min-width: 220px;
      font-size: 0.8rem;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.5);
      text-align: center;
      z-index: 4;
    }
    #mission-title {
      color: #ffd700;
      font-size: 0.7rem;
      font-weight: bold;
      letter-spacing: 2px;
      margin-bottom: 3px;
    }
    #mission-text {
      font-size: 0.85rem;
      font-weight: bold;
      text-shadow: 1px 1px 2px #000;
    }

    /* Î≤ÑÌÇ∑ Î°úÎìú Í≤åÏù¥ÏßÄ */
    #load-gauge-container {
      position: absolute;
      top: 60px;
      right: 10px;
      width: 22px;
      height: 140px;
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid #777;
      border-radius: 8px;
      overflow: hidden;
      z-index: 4;
    }
    #load-fill {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 0%;
      background: linear-gradient(to top, #5d4037, #8d6e63);
      transition: height 0.1s;
    }
    #load-label {
      position: absolute;
      top: 205px;
      right: 6px;
      color: #fff;
      font-size: 0.6rem;
      font-weight: bold;
      text-shadow: 1px 1px 2px #000;
      text-align: center;
      width: 40px;
      z-index: 4;
    }

    /* Ï°∞Ïûë Í∞ÄÏù¥Îìú */
    #instructions {
      position: absolute;
      left: 10px;
      bottom: 90px;
      background: linear-gradient(90deg, rgba(0, 0, 0, 0.8), transparent);
      color: #fff;
      padding: 10px 14px;
      border-radius: 10px;
      border-left: 4px solid #ffd700;
      max-width: 260px;
      font-size: 0.75rem;
      pointer-events: auto;
      z-index: 4;
    }
    #instructions h2 {
      margin: 0 0 6px 0;
      font-size: 0.9rem;
      color: #ffd700;
      text-shadow: 2px 2px 2px #000;
    }
    #instructions ul {
      list-style: none;
      padding-left: 10px;
      margin: 0;
    }
    #instructions li {
      margin-bottom: 2px;
    }
    .key {
      display: inline-block;
      background: #333;
      border-radius: 4px;
      padding: 1px 4px;
      border: 1px solid #555;
      font-family: monospace;
      font-size: 0.7rem;
      margin-right: 2px;
    }
    .key.special {
      color: #ffd700;
      border-color: #ffd700;
    }
    .tip {
      color: #ffd700;
      margin-top: 4px;
    }

    /* ÌïòÎã® ÌÅ¨Î†àÎîß */
    #credit-box {
      position: absolute;
      left: 10px;
      bottom: 10px;
      pointer-events: auto;
      font-size: 0.7rem;
      background: rgba(0, 0, 0, 0.7);
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #ddd;
      z-index: 4;
    }
    #credit-box a {
      color: #ffd700;
      text-decoration: none;
    }
    #credit-box a:hover {
      text-decoration: underline;
    }

    /* Î™®Î∞îÏùº Ïª®Ìä∏Î°§Îü¨ */
    #controls-container {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      padding: 8px 10px;
      display: flex;
      justify-content: space-between;
      pointer-events: auto;
      background: linear-gradient(0deg, rgba(0, 0, 0, 0.9), transparent);
      z-index: 3;
      box-sizing: border-box;
    }
    .control-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      background: rgba(40, 40, 40, 0.8);
      padding: 6px 8px;
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.15);
    }
    .label {
      color: #aaa;
      font-size: 0.7rem;
      font-weight: bold;
      margin-bottom: 3px;
      letter-spacing: 1px;
    }
    .btn-row {
      display: flex;
      gap: 6px;
      margin: 2px 0;
    }
    .ctrl-btn {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 1px solid #555;
      background: radial-gradient(circle at 30% 30%, #444, #111);
      color: #eee;
      font-size: 0.9rem;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5),
        inset 0 1px 1px rgba(255, 255, 255, 0.2);
      -webkit-tap-highlight-color: transparent;
    }
    .ctrl-btn:active {
      background: #ffd700;
      color: #000;
      transform: scale(0.96);
    }

    @media (max-width: 768px) {
      #instructions {
        display: none;
      }
      .ctrl-btn {
        width: 34px;
        height: 34px;
        font-size: 0.8rem;
      }
      .control-group {
        padding: 4px 6px;
      }
    }
  </style>

  <!-- three.jsÎßå ÏÇ¨Ïö© (OrbitControls, RoundedBoxGeometry Ï†ÑÎ∂Ä Ï†úÍ±∞) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
</head>
<body>
  <div id="excavator-wrapper">
    <div id="start-overlay">
      <h1>REAL EXCAVATOR V48</h1>
      <p>
        F: Dig (ÎïÖÌååÍ∏∞) | R: Dump (Î≤ÑÎ¶¨Í∏∞)<br />Arrows: Move | WASD + QE: Arm
        Control
      </p>
      <button id="start-btn" type="button">ÏûëÏóÖ ÏãúÏûë</button>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
      <div id="top-left-buttons">
        <button id="reset-btn" class="top-btn" type="button">Ï¥àÍ∏∞Ìôî</button>
        <button id="sound-btn" class="top-btn" type="button">üîä ÏÇ¨Ïö¥Îìú</button>
        <button id="guide-toggle-btn" class="top-btn" type="button">
          Í∞ÄÏù¥Îìú Ïà®Í∏∞Í∏∞
        </button>
        <button id="share-btn" class="top-btn" type="button">Í≥µÏú†</button>
      </div>

      <div id="mission-box">
        <div id="mission-title">MISSION 1</div>
        <div id="mission-text">
          F ÌÇ§Î•º Íæπ ÎàåÎü¨ ÎïÖÏùÑ ÍπäÍ≤å ÌååÎ≥¥ÏÑ∏Ïöî! (Î≤ÑÌÇ∑ Îã¥Í∏∞)
        </div>
      </div>

      <div id="load-gauge-container"><div id="load-fill"></div></div>
      <div id="load-label">DIRT</div>

      <div id="instructions">
        <h2>Ï°∞Ïûë Í∞ÄÏù¥Îìú (V48)</h2>
        <ul>
          <li>
            <span class="key">W</span><span class="key">S</span> : Î∂ê
            (ÎÇ¥Î¶¨Í∏∞/Ïò¨Î¶¨Í∏∞)
          </li>
          <li>
            <span class="key">Q</span><span class="key">E</span> : Ïïî
            (Ìé¥Í∏∞/Ï†ëÍ∏∞)
          </li>
          <li>
            <span class="key">A</span><span class="key">D</span> : Î≥∏Ï≤¥ ÌöåÏ†Ñ
          </li>
          <li>
            <span class="key special">F</span> : <b>ÎïÖÌååÍ∏∞ (Dig)</b>
          </li>
          <li><span class="key">R</span> : ÌùôÎ≤ÑÎ¶¨Í∏∞ (Dump)</li>
          <li><span class="key">Î∞©Ìñ•ÌÇ§</span> : Ï£ºÌñâ</li>
          <li class="tip">üí° ÎßàÏö∞Ïä§Î°ú ÌôîÎ©¥ÏùÑ ÎèåÎ†§Î≥¥ÏÑ∏Ïöî!</li>
        </ul>
      </div>

      <div id="credit-box">
        ÎßåÎì†Ïù¥:
        <a
          href="https://hjkim20089.tistory.com/"
          target="_blank"
          rel="noopener noreferrer"
          >hjkim20089.tistory.com</a
        >
        &nbsp;|&nbsp;
        <a
          href="http://cnh.bulgukto.or.kr/"
          target="_blank"
          rel="noopener noreferrer"
          >Ïª¥ÎÑ∑ÌïòÏö∞Ïä§</a
        >
      </div>

      <div id="controls-container">
        <div class="control-group">
          <div class="label">DRIVE</div>
          <div class="btn-row">
            <button class="ctrl-btn" id="btn-fwd" type="button">‚ñ≤</button>
          </div>
          <div class="btn-row">
            <button class="ctrl-btn" id="btn-left" type="button">‚óÄ</button>
            <button class="ctrl-btn" id="btn-back" type="button">‚ñº</button>
            <button class="ctrl-btn" id="btn-right" type="button">‚ñ∂</button>
          </div>
        </div>

        <div class="control-group">
          <div class="label">HYDRAULICS</div>
          <div class="btn-row">
            <button class="ctrl-btn" id="btn-boom-up" type="button">
              Î∂ê(S)‚Üë
            </button>
            <button class="ctrl-btn" id="btn-boom-down" type="button">
              Î∂ê(W)‚Üì
            </button>
          </div>
          <div class="btn-row">
            <button class="ctrl-btn" id="btn-arm-out" type="button">
              Ïïî(E)‚Üë
            </button>
            <button class="ctrl-btn" id="btn-arm-in" type="button">
              Ïïî(Q)‚Üì
            </button>
          </div>
          <div class="btn-row">
            <button class="ctrl-btn" id="btn-bucket-in" type="button">
              ÎïÖÌååÍ∏∞(F)
            </button>
            <button class="ctrl-btn" id="btn-bucket-out" type="button">
              Î≤ÑÎ¶¨Í∏∞(R)
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ===== ÏÇ¨Ïö¥Îìú Îß§ÎãàÏ†Ä =====
    class SoundManager {
      constructor() {
        this.ctx = null;
        this.isInit = false;
        this.lastDigTime = 0;
        this.engineOsc = null;
        this.engineGain = null;
        this.muted = false;
      }
      init() {
        if (this.isInit) return;
        const AC = window.AudioContext || window.webkitAudioContext;
        try {
          this.ctx = new AC();
        } catch (e) {
          console.warn("AudioContext Ïã§Ìå®", e);
          return;
        }
        this.engineOsc = this.ctx.createOscillator();
        this.engineOsc.type = "sawtooth";
        this.engineOsc.frequency.value = 40;
        this.engineGain = this.ctx.createGain();
        this.engineGain.gain.value = 0.05;
        const f = this.ctx.createBiquadFilter();
        f.type = "lowpass";
        f.frequency.value = 250;
        this.engineOsc.connect(f);
        f.connect(this.engineGain);
        this.engineGain.connect(this.ctx.destination);
        this.engineOsc.start();
        this.isInit = true;
      }
      setRPM(active, load) {
        if (!this.isInit) return;
        const t = this.ctx.currentTime;
        const targetFreq = active ? (load ? 55 : 60) : 40;
        const baseVol = active ? 0.1 : 0.05;
        const targetVol = this.muted ? 0 : baseVol;
        this.engineOsc.frequency.setTargetAtTime(targetFreq, t, 0.2);
        this.engineGain.gain.setTargetAtTime(targetVol, t, 0.2);
      }
      playDig() {
        if (!this.isInit || this.muted) return;
        const now = this.ctx.currentTime;
        if (now - this.lastDigTime < 0.15) return;
        this.lastDigTime = now;
        const buf = this.ctx.createBuffer(1, 22050, 44100);
        const d = buf.getChannelData(0);
        for (let i = 0; i < 22050; i++) {
          d[i] = (Math.random() * 2 - 1) * Math.exp(-i / 800);
        }
        const src = this.ctx.createBufferSource();
        src.buffer = buf;
        const g = this.ctx.createGain();
        g.gain.value = 0.4;
        const f = this.ctx.createBiquadFilter();
        f.type = "lowpass";
        f.frequency.value = 300;
        src.connect(f);
        f.connect(g);
        g.connect(this.ctx.destination);
        src.start();
      }
      playComplete() {
        if (!this.isInit || this.muted) return;
        const osc = this.ctx.createOscillator();
        osc.type = "sine";
        osc.frequency.setValueAtTime(600, this.ctx.currentTime);
        osc.frequency.linearRampToValueAtTime(
          1200,
          this.ctx.currentTime + 0.1
        );
        const g = this.ctx.createGain();
        g.gain.value = 0.3;
        g.gain.exponentialRampToValueAtTime(
          0.01,
          this.ctx.currentTime + 0.4
        );
        osc.connect(g);
        g.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.4);
      }
      toggleMute() {
        this.muted = !this.muted;
        if (this.isInit && this.engineGain) {
          const t = this.ctx.currentTime;
          const targetVol = this.muted ? 0 : 0.05;
          this.engineGain.gain.setTargetAtTime(targetVol, t, 0.1);
        }
        const btn = document.getElementById("sound-btn");
        if (btn) btn.textContent = this.muted ? "üîá ÏÇ¨Ïö¥Îìú" : "üîä ÏÇ¨Ïö¥Îìú";
      }
    }
    const soundMgr = new SoundManager();

    // ===== Ï†ÑÏó≠ ÏÉÅÌÉú =====
    let scene, camera, renderer;
    const excavator = {
      group: null,
      body: null,
      boom: null,
      arm: null,
      bucket: null,
      dirtVolume: null,
      bucketTip: null,
      cnhPlate: null,
      boomAng: 0.5,
      armAng: -2.0,
      bucketAng: 0.5,
    };
    const inputs = { fwd: 0, turn: 0, rot: 0, boom: 0, arm: 0, bucket: 0 };
    const SPEED = { move: 0.08, turn: 0.015, joint: 0.01 };

    const TERRAIN_SIZE = 120;
    const TERRAIN_RES = 96;
    let terrainMesh;
    const terrainData = new Float32Array(
      (TERRAIN_RES + 1) * (TERRAIN_RES + 1)
    );
    let terrainInitHeights = null;
    let terrainInitColors = null;

    let raycaster, mouse;
    const particles = [];

    const gameState = { dirtLoad: 0, hasDug: false, hasDumped: false };
    const missions = [
      {
        id: 1,
        text: "F ÌÇ§Î•º Íæπ ÎàåÎü¨ ÎïÖÏùÑ ÍπäÍ≤å ÌååÎ≥¥ÏÑ∏Ïöî! (Î≤ÑÌÇ∑ Îã¥Í∏∞)",
        check: () => gameState.hasDug,
        complete: false,
        progress: 0,
      },
      {
        id: 2,
        text: "R ÌÇ§Î•º ÎàåÎü¨ ÌùôÏùÑ ÏòÜÏóê ÏèüÏïÑÎ≥¥ÏÑ∏Ïöî (Î≤ÑÌÇ∑ Ìé¥Í∏∞)",
        check: () => gameState.hasDumped,
        complete: false,
        progress: 0,
      },
    ];
    let currentMissionIdx = 0;

    // Ïπ¥Î©îÎùº Ïò§ÎπÑÌä∏(ÏßÅÏ†ë Íµ¨ÌòÑ)
    const orbit = {
      theta: Math.PI / 4,
      phi: Math.PI / 4,
      radius: 20,
      target: new THREE.Vector3(0, 1.5, 0),
      isDragging: false,
      lastX: 0,
      lastY: 0,
    };

    function updateCameraOrbit() {
      const r = orbit.radius;
      const t = orbit.theta;
      const p = orbit.phi;
      const ct = Math.cos(t),
        st = Math.sin(t);
      const cp = Math.cos(p),
        sp = Math.sin(p);

      const x = orbit.target.x + r * sp * ct;
      const y = orbit.target.y + r * cp;
      const z = orbit.target.z + r * sp * st;
      camera.position.set(x, y, z);
      camera.lookAt(orbit.target);
    }

    function getTerrainHeight(x, z) {
      const half = TERRAIN_SIZE / 2;
      let gx = ((x + half) / TERRAIN_SIZE) * TERRAIN_RES;
      let gz = ((z + half) / TERRAIN_SIZE) * TERRAIN_RES;
      if (gx < 0 || gx >= TERRAIN_RES || gz < 0 || gz >= TERRAIN_RES) return 0;
      const x0 = Math.floor(gx),
        z0 = Math.floor(gz);
      const x1 = Math.min(x0 + 1, TERRAIN_RES);
      const z1 = Math.min(z0 + 1, TERRAIN_RES);
      const tx = gx - x0,
        tz = gz - z0;
      const i00 = z0 * (TERRAIN_RES + 1) + x0;
      const i10 = z0 * (TERRAIN_RES + 1) + x1;
      const i01 = z1 * (TERRAIN_RES + 1) + x0;
      const i11 = z1 * (TERRAIN_RES + 1) + x1;
      const h00 = terrainData[i00],
        h10 = terrainData[i10],
        h01 = terrainData[i01],
        h11 = terrainData[i11];
      const h0 = h00 * (1 - tx) + h10 * tx;
      const h1 = h01 * (1 - tx) + h11 * tx;
      return h0 * (1 - tz) + h1 * tz;
    }

    function createTerrain() {
      const geo = new THREE.PlaneGeometry(
        TERRAIN_SIZE,
        TERRAIN_SIZE,
        TERRAIN_RES,
        TERRAIN_RES
      );
      geo.rotateX(-Math.PI / 2);
      const pos = geo.attributes.position;
      const count = pos.count;
      geo.setAttribute(
        "color",
        new THREE.BufferAttribute(new Float32Array(count * 3), 3)
      );
      const col = geo.attributes.color;

      const baseC = new THREE.Color(0xc2b280);
      const hillC = new THREE.Color(0x8d6e63);

      for (let i = 0; i < count; i++) {
        const x = pos.getX(i);
        const z = pos.getZ(i);
        let y = Math.sin(x * 0.1) * 0.2 + Math.cos(z * 0.1) * 0.2;
        const d1 = Math.sqrt((x - 20) ** 2 + (z - 10) ** 2);
        if (d1 < 25) y += (25 - d1) * 0.25;
        const d2 = Math.sqrt((x + 20) ** 2 + (z + 20) ** 2);
        if (d2 < 20) y += (20 - d2) * 0.2;
        const d3 = Math.sqrt(x * x + (z + 25) ** 2);
        if (d3 < 20) y += (20 - d3) * 0.3;
        if (Math.sqrt(x * x + z * z) < 8) y = 0;

        pos.setY(i, y);
        terrainData[i] = y;

        const t = Math.min(1, Math.max(0, (y - 0.5) / 3));
        const c = baseC.clone().lerp(hillC, t);
        col.setXYZ(i, c.r, c.g, c.b);
      }

      geo.computeVertexNormals();
      const mat = new THREE.MeshStandardMaterial({
        vertexColors: true,
        roughness: 1.0,
      });
      terrainMesh = new THREE.Mesh(geo, mat);
      terrainMesh.receiveShadow = true;
      scene.add(terrainMesh);

      terrainInitHeights = new Float32Array(terrainData.length);
      terrainInitHeights.set(terrainData);
      terrainInitColors = new Float32Array(col.array.length);
      terrainInitColors.set(col.array);
    }

    function modifyTerrain(x, z, delta) {
      if (!terrainMesh) return;
      const posAttr = terrainMesh.geometry.attributes.position;
      const colAttr = terrainMesh.geometry.attributes.color;
      const half = TERRAIN_SIZE / 2;
      const gx = Math.floor(((x + half) / TERRAIN_SIZE) * TERRAIN_RES);
      const gz = Math.floor(((z + half) / TERRAIN_SIZE) * TERRAIN_RES);
      const radius = 2;
      let modified = false;

      for (let i = -radius; i <= radius; i++) {
        for (let j = -radius; j <= radius; j++) {
          const xi = gx + i;
          const zi = gz + j;
          if (
            xi < 0 ||
            xi > TERRAIN_RES ||
            zi < 0 ||
            zi > TERRAIN_RES
          )
            continue;
          const dist = Math.sqrt(i * i + j * j);
          if (dist > radius) continue;
          const idx = zi * (TERRAIN_RES + 1) + xi;
          let h = posAttr.getY(idx);
          const factor = (1 - dist / radius) * delta * 0.5;
          h += factor;
          if (delta < 0 && h < -2.5) h = -2.5;
          if (delta > 0 && h > 8) h = 8;
          posAttr.setY(idx, h);
          terrainData[idx] = h;
          if (delta < 0) colAttr.setXYZ(idx, 0.2, 0.15, 0.1);
          else colAttr.setXYZ(idx, 0.35, 0.25, 0.2);
          modified = true;
        }
      }
      if (modified) {
        posAttr.needsUpdate = true;
        colAttr.needsUpdate = true;
        terrainMesh.geometry.computeVertexNormals();
      }
    }

    function createEnvironment() {
      const coneGeo = new THREE.CylinderGeometry(0.05, 0.3, 0.6, 16);
      const coneMat = new THREE.MeshStandardMaterial({
        color: 0xff4400,
        roughness: 0.2,
      });
      const whiteMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.2,
      });

      for (let i = 0; i < 8; i++) {
        const grp = new THREE.Group();
        const base = new THREE.Mesh(coneGeo, coneMat);
        base.position.y = 0.3;
        const str = new THREE.Mesh(
          new THREE.CylinderGeometry(0.12, 0.2, 0.15, 16),
          whiteMat
        );
        str.position.y = 0.35;
        grp.add(base, str);
        const a = (i / 8) * Math.PI * 2;
        const x = Math.cos(a) * 10;
        const z = Math.sin(a) * 10;
        grp.position.set(x, getTerrainHeight(x, z), z);
        grp.castShadow = true;
        scene.add(grp);
      }
    }

    function createLogoTexture() {
      const c = document.createElement("canvas");
      c.width = 256;
      c.height = 64;
      const ctx = c.getContext("2d");
      ctx.fillStyle = "#FFA500";
      ctx.fillRect(0, 0, 256, 64);
      ctx.font = "bold 40px Arial";
      ctx.fillStyle = "#000";
      ctx.textAlign = "center";
      ctx.fillText("HEAVY v48", 128, 45);
      return new THREE.CanvasTexture(c);
    }

    function createCnhTexture() {
      const c = document.createElement("canvas");
      c.width = 512;
      c.height = 128;
      const ctx = c.getContext("2d");
      ctx.fillStyle = "#111";
      ctx.fillRect(0, 0, 512, 128);
      ctx.strokeStyle = "#ffd700";
      ctx.lineWidth = 4;
      ctx.strokeRect(4, 4, 504, 120);
      ctx.font = "bold 46px sans-serif";
      ctx.fillStyle = "#ffd700";
      ctx.textAlign = "center";
      ctx.fillText("Ïª¥ÎÑ∑ÌïòÏö∞Ïä§", 256, 60);
      ctx.font = "24px sans-serif";
      ctx.fillStyle = "#9fd4ff";
      ctx.fillText("cnh.bulgukto.or.kr", 256, 100);
      return new THREE.CanvasTexture(c);
    }

    function buildExcavator() {
      excavator.group = new THREE.Group();
      scene.add(excavator.group);

      // ÌïòÎ∂Ä Ìä∏Îûô
      const tracks = new THREE.Group();
      excavator.group.add(tracks);
      const trackMat = new THREE.MeshStandardMaterial({
        color: 0x1a1a1a,
        roughness: 0.7,
      });
      const buildTrack = (zOff) => {
        const t = new THREE.Group();
        t.position.set(0, 0.5, zOff);
        const frame = new THREE.Mesh(
          new THREE.BoxGeometry(5.5, 0.8, 0.8),
          trackMat
        );
        t.add(frame);
        return t;
      };
      tracks.add(buildTrack(1.4), buildTrack(-1.4));
      const center = new THREE.Mesh(
        new THREE.BoxGeometry(3, 0.4, 2.2),
        trackMat
      );
      center.position.y = 0.6;
      excavator.group.add(center);

      // ÏÉÅÎ∂Ä Î™∏ÌÜµ
      excavator.body = new THREE.Group();
      excavator.body.position.y = 1.1;
      excavator.group.add(excavator.body);

      const bodyMat = new THREE.MeshStandardMaterial({
        color: 0xffb300,
        roughness: 0.3,
        metalness: 0.3,
      });
      const deck = new THREE.Mesh(
        new THREE.BoxGeometry(3.6, 1.2, 3.4),
        bodyMat
      );
      deck.position.set(-0.4, 0.6, 0);
      deck.castShadow = true;
      excavator.body.add(deck);

      // Î∂ê
      excavator.boom = new THREE.Group();
      excavator.boom.position.set(0.8, 1.5, -0.5);
      excavator.body.add(excavator.boom);

      const boomMesh = new THREE.Mesh(
        new THREE.BoxGeometry(0.8, 6.0, 0.6),
        bodyMat
      );
      boomMesh.position.set(0, 3.0, 0);
      boomMesh.castShadow = true;
      excavator.boom.add(boomMesh);

      const logoTex = createLogoTexture();
      const logoMat = new THREE.MeshStandardMaterial({
        map: logoTex,
        roughness: 0.3,
      });
      const lp = new THREE.Mesh(
        new THREE.PlaneGeometry(0.6, 3),
        logoMat
      );
      lp.position.set(0.41, 3.0, 0);
      lp.rotation.set(0, Math.PI / 2, -Math.PI / 2);
      excavator.boom.add(lp);

      // Ïïî
      excavator.arm = new THREE.Group();
      excavator.arm.position.set(0, 5.8, 0);
      excavator.boom.add(excavator.arm);

      const armShape = new THREE.Shape();
      armShape.moveTo(-0.3, 0.6);
      armShape.lineTo(0.3, 0.6);
      armShape.lineTo(0.25, -3.2);
      armShape.lineTo(-0.25, -3.2);
      armShape.lineTo(-0.3, 0.6);
      const armGeo = new THREE.ExtrudeGeometry(armShape, {
        depth: 0.5,
        bevelEnabled: true,
        bevelThickness: 0.03,
        bevelSize: 0.03,
        bevelSegments: 3,
      });
      const armMesh = new THREE.Mesh(armGeo, bodyMat);
      armMesh.position.set(0, 0, -0.25);
      excavator.arm.add(armMesh);

      // Î≤ÑÌÇ∑
      excavator.bucket = new THREE.Group();
      excavator.bucket.position.set(0, -3.2, 0);
      excavator.arm.add(excavator.bucket);

      const bucketGroup = new THREE.Group();
      bucketGroup.position.set(0, -0.6, 0);
      bucketGroup.rotation.y = Math.PI / 2;
      excavator.bucket.add(bucketGroup);

      const sideShape = new THREE.Shape();
      sideShape.moveTo(0.85, 0);
      sideShape.lineTo(0, 0);
      sideShape.quadraticCurveTo(-0.55, 0, -0.55, 0.6);
      sideShape.lineTo(-0.55, 0.8);
      sideShape.lineTo(-0.5, 0.8);
      sideShape.lineTo(-0.5, 0.6);
      sideShape.quadraticCurveTo(-0.5, 0.05, 0, 0.05);
      sideShape.lineTo(0.85, 0.05);
      sideShape.lineTo(0.85, 0);

      const bw = 0.9;
      const bucketGeo = new THREE.ExtrudeGeometry(sideShape, {
        depth: bw,
        bevelEnabled: false,
        curveSegments: 12,
      });
      const bucketMat = new THREE.MeshStandardMaterial({
        color: 0x222222,
        roughness: 0.8,
      });
      const bucketMesh = new THREE.Mesh(bucketGeo, bucketMat);
      bucketMesh.position.set(0, 0, -bw / 2);
      bucketGroup.add(bucketMesh);

      const toothGeo = new THREE.CylinderGeometry(0, 0.07, 0.45, 4);
      const toothMat = new THREE.MeshStandardMaterial({
        color: 0x999999,
        roughness: 0.5,
        metalness: 0.7,
      });
      for (let i = 0; i < 5; i++) {
        const t = new THREE.Mesh(toothGeo, toothMat);
        t.rotation.set(Math.PI / 4, 0, -Math.PI / 2);
        t.position.set(
          1.15,
          0.03,
          -bw / 2 + 0.05 + (i * (bw - 0.1)) / 4
        );
        bucketGroup.add(t);
      }

      const dirtGeo = new THREE.CylinderGeometry(
        0.4,
        0.4,
        bw,
        8,
        1,
        false,
        0,
        Math.PI
      );
      const dirtMat = new THREE.MeshStandardMaterial({
        color: 0x5d4037,
        roughness: 1.0,
      });
      excavator.dirtVolume = new THREE.Mesh(dirtGeo, dirtMat);
      excavator.dirtVolume.rotation.x = Math.PI / 2;
      excavator.dirtVolume.position.set(0.2, 0.3, 0);
      excavator.dirtVolume.scale.set(0, 0, 1);
      bucketGroup.add(excavator.dirtVolume);

      excavator.bucketTip = new THREE.Object3D();
      excavator.bucketTip.position.set(1.2, 0.03, 0);
      bucketGroup.add(excavator.bucketTip);

      // Ïª¥ÎÑ∑ÌïòÏö∞Ïä§ ÌåêÎÑ¨ (Í≥µÏ§ëÏóê Îñ†ÏÑú ÏïûÎí§ÏóêÏÑú Î≥¥Ïù¥Í≤å)
      const cTex = createCnhTexture();
      const cMat = new THREE.MeshStandardMaterial({
        map: cTex,
        roughness: 0.4,
        metalness: 0.2,
        side: THREE.DoubleSide,
      });
      const cnhPlate = new THREE.Mesh(
        new THREE.PlaneGeometry(2.8, 1.0),
        cMat
      );
      cnhPlate.position.set(0, 5.0, 0);
      cnhPlate.castShadow = true;
      excavator.body.add(cnhPlate);
      excavator.cnhPlate = cnhPlate;

      // Ï¥àÍ∏∞ Í∞ÅÎèÑ
      excavator.boom.rotation.x = excavator.boomAng;
      excavator.arm.rotation.x = excavator.armAng;
      excavator.bucket.rotation.x = excavator.bucketAng;
    }

    function spawnParticle(pos, type) {
      const geo = new THREE.PlaneGeometry(0.3, 0.3);
      const mat =
        type === "dust"
          ? new THREE.MeshBasicMaterial({
              color: 0xd7ccc8,
              transparent: true,
              opacity: 0.3,
              depthWrite: false,
            })
          : new THREE.MeshStandardMaterial({
              color: 0x5d4037,
              roughness: 1.0,
            });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.copy(pos);
      mesh.position.x += (Math.random() - 0.5) * 0.5;
      mesh.position.z += (Math.random() - 0.5) * 0.5;
      mesh.lookAt(camera.position);
      scene.add(mesh);
      particles.push({
        mesh,
        life: 1,
        vel: new THREE.Vector3(
          (Math.random() - 0.5) * 0.05,
          0.05,
          (Math.random() - 0.5) * 0.05
        ),
      });
    }

    function updateMission() {
      const titleEl = document.getElementById("mission-title");
      const textEl = document.getElementById("mission-text");
      if (currentMissionIdx >= missions.length) {
        if (titleEl) titleEl.innerText = "MISSION";
        if (textEl) textEl.innerText = "ÏûêÏú† ÏûëÏóÖ Î™®Îìú!";
        return;
      }
      const m = missions[currentMissionIdx];
      if (titleEl) titleEl.innerText = "MISSION " + m.id;
      if (textEl) textEl.innerText = m.text;
      if (m.check()) m.progress += 0.05;
      if (m.progress >= 1 && !m.complete) {
        m.complete = true;
        soundMgr.playComplete();
        currentMissionIdx++;
      }
    }

    function updateExcavator() {
      // Ï£ºÌñâ
      if (Math.abs(inputs.fwd) > 0.1 || Math.abs(inputs.turn) > 0.1) {
        const spd = inputs.fwd * SPEED.move;
        const rot = inputs.turn * SPEED.turn;
        excavator.group.rotation.y += rot;
        excavator.group.position.x +=
          Math.cos(excavator.group.rotation.y) * spd;
        excavator.group.position.z -=
          Math.sin(excavator.group.rotation.y) * spd;
      }

      // Ïñ∏ÎçïÏóêÏÑú Í∏∞Ïö∏Í∏∞ / ÎïÖÏÜç Î∞©ÏßÄ
      (function () {
        const gx = excavator.group.position.x;
        const gz = excavator.group.position.z;
        const yaw = excavator.group.rotation.y;
        const d = 1.5;
        const cosY = Math.cos(yaw),
          sinY = Math.sin(yaw);
        const centerH = getTerrainHeight(gx, gz);
        const frontX = gx + cosY * d,
          frontZ = gz - sinY * d;
        const backX = gx - cosY * d,
          backZ = gz + sinY * d;
        const leftX = gx - sinY * d,
          leftZ = gz - cosY * d;
        const rightX = gx + sinY * d,
          rightZ = gz + cosY * d;
        const hFront = getTerrainHeight(frontX, frontZ);
        const hBack = getTerrainHeight(backX, backZ);
        const hLeft = getTerrainHeight(leftX, leftZ);
        const hRight = getTerrainHeight(rightX, rightZ);
        const avg = (centerH + hFront + hBack + hLeft + hRight) / 5;
        const groundOffset = 0.05;
        let targetY = avg + groundOffset;
        let ny = THREE.MathUtils.lerp(
          excavator.group.position.y,
          targetY,
          0.2
        );
        if (ny < targetY) ny = targetY;
        excavator.group.position.y = ny;

        const slopeF = (hFront - hBack) / (2 * d);
        const slopeS = (hLeft - hRight) / (2 * d);
        const pitch = Math.atan2(slopeF, 1);
        const roll = Math.atan2(slopeS, 1);
        const maxTilt = 0.5;
        const cp = THREE.MathUtils.clamp(pitch, -maxTilt, maxTilt);
        const cr = THREE.MathUtils.clamp(roll, -maxTilt, maxTilt);
        excavator.group.rotation.x = THREE.MathUtils.lerp(
          excavator.group.rotation.x,
          cp,
          0.2
        );
        excavator.group.rotation.z = THREE.MathUtils.lerp(
          excavator.group.rotation.z,
          cr,
          0.2
        );
      })();

      // ÏÉÅÎ∂Ä ÌöåÏ†Ñ
      if (inputs.rot) excavator.body.rotation.y += inputs.rot * SPEED.turn;

      // Î∂ê/Ïïî/Î≤ÑÌÇ∑ Í∞ÅÎèÑ
      if (inputs.boom) excavator.boomAng += inputs.boom * SPEED.joint;
      if (inputs.arm) excavator.armAng += inputs.arm * SPEED.joint;
      if (inputs.bucket) excavator.bucketAng += inputs.bucket * SPEED.joint;

      // Í∞ÅÎèÑ Ï†úÌïú (Î≤ÑÌÇ∑ ÏïΩ 100ÎèÑ Ï†ïÎèÑ)
      excavator.boomAng = THREE.MathUtils.clamp(
        excavator.boomAng,
        -0.2,
        2.0
      );
      excavator.armAng = THREE.MathUtils.clamp(
        excavator.armAng,
        -3.2,
        -0.2
      );
      excavator.bucketAng = THREE.MathUtils.clamp(
        excavator.bucketAng,
        -0.2,
        1.5
      );

      excavator.boom.rotation.x = excavator.boomAng;
      excavator.arm.rotation.x = excavator.armAng;
      excavator.bucket.rotation.x = excavator.bucketAng;

      // Î≤ÑÌÇ∑ ÎÅù ÏúÑÏπò
      const tipWorld = new THREE.Vector3();
      excavator.bucketTip.getWorldPosition(tipWorld);
      const tH = getTerrainHeight(tipWorld.x, tipWorld.z);

      // ÎïÖÏóê ÎãøÏùÄ ÏÉÅÌÉúÏóêÏÑú ÎïÖÌååÍ∏∞
      if (tipWorld.y < tH + 0.15) {
        if (inputs.bucket > 0) {
          gameState.hasDug = true;
          if (gameState.dirtLoad < 1) {
            gameState.dirtLoad += 0.005;
            modifyTerrain(tipWorld.x, tipWorld.z, -0.15);
            soundMgr.playDig();
            spawnParticle(tipWorld, "dust");
          }
        }
      }

      // Dump
      if (inputs.bucket < 0 && gameState.dirtLoad > 0) {
        gameState.hasDumped = true;
        gameState.dirtLoad -= 0.01;
        modifyTerrain(tipWorld.x, tipWorld.z, 0.2);
        spawnParticle(tipWorld, "dirt");
      }

      // Î≤ÑÌÇ∑ Ïïà Ìùô
      if (excavator.dirtVolume) {
        const s = gameState.dirtLoad;
        excavator.dirtVolume.scale.set(s, s, 1);
        excavator.dirtVolume.visible = s > 0.05;
      }

      // Í≤åÏù¥ÏßÄ
      const fill = document.getElementById("load-fill");
      if (fill) fill.style.height = gameState.dirtLoad * 100 + "%";

      // ÏóîÏßÑ ÏÇ¨Ïö¥Îìú
      const active = Object.values(inputs).some((v) => v !== 0);
      soundMgr.setRPM(active, false);
    }

    function resetGame() {
      for (const k in inputs) inputs[k] = 0;
      gameState.dirtLoad = 0;
      gameState.hasDug = false;
      gameState.hasDumped = false;
      currentMissionIdx = 0;
      missions.forEach((m) => {
        m.complete = false;
        m.progress = 0;
      });
      const fill = document.getElementById("load-fill");
      if (fill) fill.style.height = "0%";
      const t1 = document.getElementById("mission-title");
      const t2 = document.getElementById("mission-text");
      if (t1) t1.innerText = "MISSION 1";
      if (t2) t2.innerText = missions[0].text;

      if (terrainMesh && terrainInitHeights && terrainInitColors) {
        const pos = terrainMesh.geometry.attributes.position;
        const col = terrainMesh.geometry.attributes.color;
        const count = pos.count;
        for (let i = 0; i < count; i++) {
          const h = terrainInitHeights[i];
          pos.setY(i, h);
          terrainData[i] = h;
          const r = terrainInitColors[i * 3];
          const g = terrainInitColors[i * 3 + 1];
          const b = terrainInitColors[i * 3 + 2];
          col.setXYZ(i, r, g, b);
        }
        pos.needsUpdate = true;
        col.needsUpdate = true;
        terrainMesh.geometry.computeVertexNormals();
      }

      excavator.group.position.set(0, 0.1, 0);
      excavator.group.rotation.set(0, 0, 0);
      excavator.body.rotation.set(0, 0, 0);
      excavator.boomAng = 0.5;
      excavator.armAng = -2.0;
      excavator.bucketAng = 0.5;
      excavator.boom.rotation.x = excavator.boomAng;
      excavator.arm.rotation.x = excavator.armAng;
      excavator.bucket.rotation.x = excavator.bucketAng;

      if (excavator.dirtVolume) {
        excavator.dirtVolume.scale.set(0, 0, 1);
        excavator.dirtVolume.visible = false;
      }

      particles.forEach((p) => scene.remove(p.mesh));
      particles.length = 0;

      orbit.radius = 20;
      orbit.theta = Math.PI / 4;
      orbit.phi = Math.PI / 4;
      orbit.target.set(
        excavator.group.position.x,
        excavator.group.position.y + 1.5,
        excavator.group.position.z
      );
      updateCameraOrbit();
    }

    function setupInput() {
      const onKey = (e, v) => {
        switch (e.code) {
          case "ArrowUp":
            inputs.fwd = v;
            break;
          case "ArrowDown":
            inputs.fwd = -v;
            break;
          case "ArrowLeft":
            inputs.turn = v;
            break;
          case "ArrowRight":
            inputs.turn = -v;
            break;
          case "KeyW":
            inputs.boom = v;
            break;
          case "KeyS":
            inputs.boom = -v;
            break;
          case "KeyE":
            inputs.arm = v;
            break;
          case "KeyQ":
            inputs.arm = -v;
            break;
          case "KeyF":
            inputs.bucket = v;
            break;
          case "KeyR":
            inputs.bucket = -v;
            break;
          case "KeyA":
            inputs.rot = v;
            break;
          case "KeyD":
            inputs.rot = -v;
            break;
        }
      };
      window.addEventListener("keydown", (e) => onKey(e, 1));
      window.addEventListener("keyup", (e) => onKey(e, 0));

      const bind = (id, key, val) => {
        const b = document.getElementById(id);
        if (!b) return;
        const set = (v) => {
          inputs[key] = v;
        };
        b.addEventListener("mousedown", () => set(val));
        b.addEventListener("mouseup", () => set(0));
        b.addEventListener("mouseleave", () => set(0));
        b.addEventListener("touchstart", (e) => {
          e.preventDefault();
          set(val);
        });
        b.addEventListener("touchend", (e) => {
          e.preventDefault();
          set(0);
        });
      };
      bind("btn-fwd", "fwd", 1);
      bind("btn-back", "fwd", -1);
      bind("btn-left", "turn", 1);
      bind("btn-right", "turn", -1);
      bind("btn-boom-up", "boom", -1);
      bind("btn-boom-down", "boom", 1);
      bind("btn-arm-out", "arm", 1);
      bind("btn-arm-in", "arm", -1);
      bind("btn-bucket-in", "bucket", 1);
      bind("btn-bucket-out", "bucket", -1);
    }

    function setupUI() {
      const startBtn = document.getElementById("start-btn");
      if (startBtn) {
        startBtn.addEventListener("click", () => {
          const ov = document.getElementById("start-overlay");
          if (ov) ov.style.display = "none";
          soundMgr.init();
        });
      }

      const resetBtn = document.getElementById("reset-btn");
      if (resetBtn) resetBtn.addEventListener("click", resetGame);

      const soundBtn = document.getElementById("sound-btn");
      if (soundBtn)
        soundBtn.addEventListener("click", () => soundMgr.toggleMute());

      const guideBtn = document.getElementById("guide-toggle-btn");
      if (guideBtn) {
        guideBtn.addEventListener("click", () => {
          const inst = document.getElementById("instructions");
          if (!inst) return;
          const hide = inst.style.display === "none";
          inst.style.display = hide ? "block" : "none";
          guideBtn.textContent = hide ? "Í∞ÄÏù¥Îìú Ïà®Í∏∞Í∏∞" : "Í∞ÄÏù¥Îìú Î≥¥Ïù¥Í∏∞";
        });
      }

      const shareBtn = document.getElementById("share-btn");
      if (shareBtn) {
        shareBtn.addEventListener("click", async () => {
          const url = window.location.href;
          const title = "REAL EXCAVATOR V48";
          const text = "REAL EXCAVATOR V48 - Ìè¨ÌÅ¨Î†àÏù∏ ÎïÖÌååÍ∏∞ ÏãúÎÆ¨Î†àÏù¥ÌÑ∞";
          if (navigator.share) {
            try {
              await navigator.share({ title, text, url });
            } catch (e) {}
          } else if (navigator.clipboard) {
            try {
              await navigator.clipboard.writeText(url);
              alert("ÌòÑÏû¨ ÌéòÏù¥ÏßÄ Ï£ºÏÜåÎ•º ÌÅ¥Î¶ΩÎ≥¥ÎìúÏóê Î≥µÏÇ¨ÌñàÏäµÎãàÎã§.");
            } catch (e) {
              alert("Ïù¥ Ï£ºÏÜåÎ•º Î≥µÏÇ¨Ìï¥ÏÑú Í≥µÏú†Ìï¥ Ï£ºÏÑ∏Ïöî:\n" + url);
            }
          } else {
            prompt("Ïù¥ Ï£ºÏÜåÎ•º Î≥µÏÇ¨Ìï¥ÏÑú Í≥µÏú†Ìï¥ Ï£ºÏÑ∏Ïöî:", url);
          }
        });
      }
    }

    function onCanvasClick(e) {
      if (!excavator.cnhPlate) return;
      const rect = renderer.domElement.getBoundingClientRect();
      const x = (e.clientX - rect.left) / rect.width;
      const y = (e.clientY - rect.top) / rect.height;
      mouse.x = x * 2 - 1;
      mouse.y = -y * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const hit = raycaster.intersectObject(excavator.cnhPlate, true);
      if (hit.length > 0) {
        window.open("http://cnh.bulgukto.or.kr/", "_blank", "noopener");
      }
    }
    function onCanvasClickTouch(e) {
      if (!excavator.cnhPlate || !e.changedTouches[0]) return;
      const t = e.changedTouches[0];
      const rect = renderer.domElement.getBoundingClientRect();
      const x = (t.clientX - rect.left) / rect.width;
      const y = (t.clientY - rect.top) / rect.height;
      mouse.x = x * 2 - 1;
      mouse.y = -y * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const hit = raycaster.intersectObject(excavator.cnhPlate, true);
      if (hit.length > 0) {
        window.open("http://cnh.bulgukto.or.kr/", "_blank", "noopener");
      }
    }

    // ÎßàÏö∞Ïä§ ÎìúÎûòÍ∑∏Î°ú Ïπ¥Î©îÎùº ÌöåÏ†Ñ
    function onPointerDown(e) {
      orbit.isDragging = true;
      const point = e.touches ? e.touches[0] : e;
      orbit.lastX = point.clientX;
      orbit.lastY = point.clientY;
    }
    function onPointerMove(e) {
      if (!orbit.isDragging) return;
      const point = e.touches ? e.touches[0] : e;
      const dx = point.clientX - orbit.lastX;
      const dy = point.clientY - orbit.lastY;
      orbit.lastX = point.clientX;
      orbit.lastY = point.clientY;

      orbit.theta -= dx * 0.005;
      orbit.phi -= dy * 0.003;
      const minPhi = 0.2;
      const maxPhi = Math.PI / 2 - 0.1;
      if (orbit.phi < minPhi) orbit.phi = minPhi;
      if (orbit.phi > maxPhi) orbit.phi = maxPhi;
      updateCameraOrbit();
    }
    function onPointerUp() {
      orbit.isDragging = false;
    }

    function animate() {
      requestAnimationFrame(animate);
      updateExcavator();
      updateMission();

      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life -= 0.02;
        p.mesh.position.add(p.vel);
        p.mesh.lookAt(camera.position);
        p.mesh.material.opacity = p.life * 0.5;
        if (p.life <= 0) {
          scene.remove(p.mesh);
          particles.splice(i, 1);
        }
      }

      orbit.target.set(
        excavator.group.position.x,
        excavator.group.position.y + 1.5,
        excavator.group.position.z
      );
      updateCameraOrbit();

      renderer.render(scene, camera);
    }

    function init() {
      if (typeof THREE === "undefined") {
        alert(
          "three.js Î°úÎî©Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.\nÍ¥ëÍ≥† Ï∞®Îã®Ïù¥ÎÇò ÎÑ§Ìä∏ÏõåÌÅ¨(https://cdn.jsdelivr.net)Î•º ÌôïÏù∏Ìï¥ Ï£ºÏÑ∏Ïöî."
        );
        return;
      }

      const container = document.getElementById("canvas-container");
      const w = container.clientWidth || window.innerWidth;
      const h = container.clientHeight || window.innerHeight;

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);
      scene.fog = new THREE.Fog(0x87ceeb, 20, 150);

      camera = new THREE.PerspectiveCamera(55, w / h, 0.1, 500);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(w, h);
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      container.appendChild(renderer.domElement);

      const amb = new THREE.HemisphereLight(0xffffff, 0x555555, 0.7);
      scene.add(amb);
      const sun = new THREE.DirectionalLight(0xfffae0, 1.3);
      sun.position.set(30, 50, 20);
      sun.castShadow = true;
      sun.shadow.mapSize.set(2048, 2048);
      sun.shadow.camera.left = -30;
      sun.shadow.camera.right = 30;
      sun.shadow.camera.top = 30;
      sun.shadow.camera.bottom = -30;
      scene.add(sun);

      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();
      renderer.domElement.addEventListener("click", onCanvasClick);
      renderer.domElement.addEventListener("touchend", onCanvasClickTouch);

      renderer.domElement.addEventListener("mousedown", onPointerDown);
      window.addEventListener("mousemove", onPointerMove);
      window.addEventListener("mouseup", onPointerUp);
      renderer.domElement.addEventListener("touchstart", onPointerDown, {
        passive: false,
      });
      window.addEventListener("touchmove", onPointerMove, { passive: false });
      window.addEventListener("touchend", onPointerUp);

      createTerrain();
      createEnvironment();
      buildExcavator();
      setupInput();
      setupUI();

      orbit.radius = 20;
      orbit.theta = Math.PI / 4;
      orbit.phi = Math.PI / 4;
      orbit.target.set(
        excavator.group.position.x,
        excavator.group.position.y + 1.5,
        excavator.group.position.z
      );
      updateCameraOrbit();

      window.addEventListener("resize", () => {
        const w = container.clientWidth || window.innerWidth;
        const h = container.clientHeight || window.innerHeight;
        renderer.setSize(w, h);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        updateCameraOrbit();
      });

      animate();
    }

    if (
      document.readyState === "complete" ||
      document.readyState === "interactive"
    ) {
      init();
    } else {
      document.addEventListener("DOMContentLoaded", init);
    }
  </script>
</body>
</html>
