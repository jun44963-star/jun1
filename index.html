<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>REAL EXCAVATOR V48 PRO - AI Multi</title>
  <meta
    name="viewport"
    content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"
  />
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #000;
      font-family: "Noto Sans KR", system-ui, -apple-system, BlinkMacSystemFont,
        sans-serif;
      overflow: hidden;
    }

    #excavator-wrapper {
      position: relative;
      width: 100%;
      height: 100vh;
      background: #050505;
      overflow: hidden;
      box-sizing: border-box;
    }

    #canvas-container {
      position: absolute;
      inset: 0;
    }
    #ui-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    /* Start Overlay */
    #start-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 10;
      color: #fff;
      pointer-events: auto;
    }
    #start-overlay h1 {
      color: #ffd700;
      font-size: 2.2rem;
      margin-bottom: 10px;
      text-shadow: 0 0 20px #ffd700;
      text-align: center;
    }
    #start-overlay p {
      margin-bottom: 20px;
      color: #ccc;
      text-align: center;
      font-size: 0.9rem;
      line-height: 1.5;
    }
    #start-btn {
      padding: 14px 36px;
      font-size: 1.2rem;
      font-weight: 900;
      color: #111;
      background: linear-gradient(135deg, #ffd700 0%, #ffa500 100%);
      border: none;
      border-radius: 999px;
      cursor: pointer;
      box-shadow: 0 0 18px rgba(255, 165, 0, 0.6);
      text-transform: uppercase;
      letter-spacing: 2px;
    }
    #start-btn:active {
      transform: scale(0.96);
      box-shadow: 0 0 8px rgba(255, 215, 0, 0.7);
    }

    /* Top Left UI */
    #top-left-buttons {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      gap: 6px;
      pointer-events: auto;
      flex-wrap: wrap;
      z-index: 5;
    }
    .top-btn {
      padding: 6px 12px;
      font-size: 0.75rem;
      border-radius: 6px;
      border: 1px solid #555;
      background: rgba(20, 20, 20, 0.8);
      color: #eee;
      cursor: pointer;
      white-space: nowrap;
      transition: background 0.2s;
    }
    .top-btn:hover {
      background: #333;
      border-color: #ffd700;
      color: #ffd700;
    }
    .top-btn:active {
      transform: scale(0.95);
    }

    /* Mission Box */
    #mission-box {
      position: absolute;
      top: 60px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid #ffd700;
      border-radius: 8px;
      padding: 8px 18px;
      color: #fff;
      pointer-events: auto;
      min-width: 240px;
      font-size: 0.8rem;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      text-align: center;
      z-index: 4;
    }
    #mission-title {
      color: #ffd700;
      font-size: 0.75rem;
      font-weight: bold;
      letter-spacing: 1px;
      margin-bottom: 4px;
      text-transform: uppercase;
    }
    #mission-text {
      font-size: 0.9rem;
      text-shadow: 1px 1px 2px #000;
    }

    /* Load Gauge */
    #load-gauge-container {
      position: absolute;
      top: 60px;
      right: 10px;
      width: 20px;
      height: 120px;
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid #666;
      border-radius: 4px;
      overflow: hidden;
      z-index: 4;
    }
    #load-fill {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 0%;
      background: linear-gradient(to top, #795548, #a1887f);
      transition: height 0.1s;
    }
    #load-label {
      position: absolute;
      top: 185px;
      right: 0px;
      color: #bbb;
      font-size: 0.6rem;
      font-weight: bold;
      text-align: center;
      width: 40px;
      z-index: 4;
    }

    /* Guide */
    #instructions {
      position: absolute;
      left: 10px;
      bottom: 100px;
      background: rgba(0, 0, 0, 0.7);
      color: #ddd;
      padding: 12px;
      border-radius: 8px;
      border-left: 3px solid #ffd700;
      max-width: 220px;
      font-size: 0.75rem;
      pointer-events: auto;
      z-index: 4;
      backdrop-filter: blur(4px);
    }
    #instructions h2 {
      margin: 0 0 8px 0;
      font-size: 0.85rem;
      color: #ffd700;
    }
    #instructions ul {
      list-style: none;
      padding-left: 0;
      margin: 0;
    }
    #instructions li {
      margin-bottom: 4px;
      display: flex;
      justify-content: space-between;
    }
    .key {
      background: #333;
      border-radius: 3px;
      padding: 1px 4px;
      border: 1px solid #555;
      font-family: monospace;
      color: #fff;
    }
    .key.special {
      border-color: #ffd700;
      color: #ffd700;
    }

    /* Mobile Controls */
    #controls-container {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 10px;
      padding: 0 10px;
      display: flex;
      justify-content: space-between;
      pointer-events: auto;
      z-index: 3;
    }
    .control-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      background: rgba(20, 20, 20, 0.6);
      padding: 8px;
      border-radius: 12px;
      backdrop-filter: blur(2px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    .label {
      color: #999;
      font-size: 0.65rem;
      font-weight: bold;
      margin-bottom: 4px;
      letter-spacing: 1px;
    }
    .btn-row {
      display: flex;
      gap: 8px;
      margin: 3px 0;
    }
    .ctrl-btn {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      border: 1px solid #555;
      background: radial-gradient(circle at 30% 30%, #444, #111);
      color: #eee;
      font-size: 0.75rem;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 3px 6px rgba(0, 0, 0, 0.6);
      -webkit-tap-highlight-color: transparent;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .ctrl-btn:active {
      background: #ffd700;
      color: #000;
      transform: scale(0.95);
      box-shadow: 0 1px 3px rgba(0,0,0,0.5);
    }

    #toast {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.85);
      color: #ffd700;
      padding: 12px 24px;
      border-radius: 8px;
      border: 1px solid #ffd700;
      z-index: 100;
      display: none;
      font-size: 1rem;
      pointer-events: none;
      text-align: center;
    }

    @media (max-width: 768px) {
      #instructions { display: none; }
      .ctrl-btn { width: 38px; height: 38px; font-size: 0.65rem; }
      .control-group { padding: 5px; }
      #mission-box { top: 50px; font-size: 0.75rem; padding: 6px 12px; min-width: 200px; }
    }
  </style>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
</head>
<body>
  <div id="excavator-wrapper">
    <div id="start-overlay">
      <h1>REAL EXCAVATOR V48 PRO</h1>
      <p>
        PC: Î∞©Ìñ•ÌÇ§(Ïù¥Îèô), WASD(Î∂ê/Ïïî), F/R(Î≤ÑÌÇ∑)<br>
        <span style="color:#ff6666; font-weight:bold;">Îπ®Í∞ÑÏÉâ AI Ìè¨ÌÅ¨Î†àÏù∏Ïù¥ Ìï®Íªò ÏûëÏóÖÌï©ÎãàÎã§!</span><br>
        Ïñ∏ÎçïÏùÑ ÎßåÎÇòÎ©¥ Í≥ÑÏÜç Ï†ÑÏßÑÌïòÏó¨ Î∞ÄÏñ¥ÎÇ¥ÏÑ∏Ïöî (Dozing)
      </p>
      <button id="start-btn" type="button">ÏûëÏóÖ ÏãúÏûë</button>
    </div>

    <div id="canvas-container"></div>
    <div id="toast"></div>

    <div id="ui-layer">
      <div id="top-left-buttons">
        <button id="reset-btn" class="top-btn" type="button">üîÑ Ï¥àÍ∏∞Ìôî</button>
        <button id="sound-btn" class="top-btn" type="button">üîä ÏÇ¨Ïö¥Îìú</button>
        <button id="guide-toggle-btn" class="top-btn" type="button">Í∞ÄÏù¥Îìú On/Off</button>
        <button id="share-btn" class="top-btn" type="button">üîó Í≥µÏú†</button>
      </div>

      <div id="mission-box">
        <div id="mission-title">MISSION 1</div>
        <div id="mission-text">F ÌÇ§Î•º ÎàåÎü¨ ÌùôÏùÑ ÌååÎ≥¥ÏÑ∏Ïöî!</div>
      </div>

      <div id="load-gauge-container"><div id="load-fill"></div></div>
      <div id="load-label">LOAD</div>

      <div id="instructions">
        <h2>üéÆ Ï°∞Ïûë Í∞ÄÏù¥Îìú</h2>
        <ul>
          <li><span>Î∂ê Ï†úÏñ¥</span> <span class="key">W</span><span class="key">S</span></li>
          <li><span>Ïïî Ï†úÏñ¥</span> <span class="key">Q</span><span class="key">E</span></li>
          <li><span>Î≤ÑÌÇ∑(ÌååÍ∏∞)</span> <span class="key special">F</span></li>
          <li><span>Î≤ÑÌÇ∑(Î≤ÑÎ¶º)</span> <span class="key">R</span></li>
          <li><span>Î≥∏Ï≤¥ ÌöåÏ†Ñ</span> <span class="key">A</span><span class="key">D</span></li>
          <li><span>Ïù¥Îèô</span> <span class="key">Î∞©Ìñ•ÌÇ§</span></li>
        </ul>
      </div>

      <div id="controls-container">
        <div class="control-group">
          <div class="label">TRACKS</div>
          <div class="btn-row">
            <button class="ctrl-btn" id="btn-fwd">‚ñ≤</button>
          </div>
          <div class="btn-row">
            <button class="ctrl-btn" id="btn-left">‚óÄ</button>
            <button class="ctrl-btn" id="btn-back">‚ñº</button>
            <button class="ctrl-btn" id="btn-right">‚ñ∂</button>
          </div>
        </div>
        <div class="control-group">
          <div class="label">BOOM/ARM</div>
          <div class="btn-row">
            <button class="ctrl-btn" id="btn-boom-up">Î∂ê‚Üë</button>
            <button class="ctrl-btn" id="btn-boom-down">Î∂ê‚Üì</button>
          </div>
          <div class="btn-row">
            <button class="ctrl-btn" id="btn-arm-out">Ïïî‚Üë</button>
            <button class="ctrl-btn" id="btn-arm-in">Ïïî‚Üì</button>
          </div>
        </div>
        <div class="control-group">
          <div class="label">BUCKET</div>
          <div class="btn-row">
            <button class="ctrl-btn" id="btn-bucket-in">ÌååÍ∏∞</button>
            <button class="ctrl-btn" id="btn-bucket-out">Î≤ÑÎ¶º</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    /* ================== Toast ================== */
    function showToast(msg) {
      const t = document.getElementById("toast");
      if(!t) return;
      t.innerText = msg;
      t.style.display = "block";
      setTimeout(() => { t.style.display = "none"; }, 2500);
    }

    /* ================== Sound System ================== */
    class SoundManager {
      constructor() {
        this.ctx = null;
        this.isInit = false;
        this.lastDigTime = 0;
        this.engineOsc = null;
        this.engineGain = null;
        this.muted = false;
      }
      init() {
        if (this.isInit) return;
        const AC = window.AudioContext || window.webkitAudioContext;
        try { this.ctx = new AC(); } catch (e) { return; }
        
        // Engine Idle Sound
        this.engineOsc = this.ctx.createOscillator();
        this.engineOsc.type = "sawtooth";
        this.engineOsc.frequency.value = 40;
        this.engineGain = this.ctx.createGain();
        this.engineGain.gain.value = 0.05;
        
        const filter = this.ctx.createBiquadFilter();
        filter.type = "lowpass";
        filter.frequency.value = 200;
        
        this.engineOsc.connect(filter);
        filter.connect(this.engineGain);
        this.engineGain.connect(this.ctx.destination);
        this.engineOsc.start();
        this.isInit = true;
      }
      setRPM(active, load) {
        if (!this.isInit) return;
        const now = this.ctx.currentTime;
        const targetFreq = active ? (load ? 55 : 50) : 35; 
        const targetVol = this.muted ? 0 : (active ? 0.08 : 0.04);
        this.engineOsc.frequency.setTargetAtTime(targetFreq, now, 0.3);
        this.engineGain.gain.setTargetAtTime(targetVol, now, 0.2);
      }
      playDig() {
        if (!this.isInit || this.muted) return;
        if (this.ctx.currentTime - this.lastDigTime < 0.2) return;
        this.lastDigTime = this.ctx.currentTime;
        const buf = this.ctx.createBuffer(1, 22050, 44100);
        const data = buf.getChannelData(0);
        for(let i=0; i<data.length; i++) data[i] = (Math.random()*2 - 1) * Math.exp(-i/1000);
        const src = this.ctx.createBufferSource();
        src.buffer = buf;
        const gain = this.ctx.createGain();
        gain.gain.value = 0.3;
        src.connect(gain);
        gain.connect(this.ctx.destination);
        src.start();
      }
      playSuccess() {
        if (!this.isInit || this.muted) return;
        const osc = this.ctx.createOscillator();
        osc.type = "sine";
        osc.frequency.setValueAtTime(500, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(1000, this.ctx.currentTime + 0.1);
        const g = this.ctx.createGain();
        g.gain.setValueAtTime(0.1, this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
        osc.connect(g);
        g.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.5);
      }
      toggleMute() {
        this.muted = !this.muted;
        if (this.isInit && this.engineGain) {
          this.engineGain.gain.setTargetAtTime(this.muted ? 0 : 0.04, this.ctx.currentTime, 0.1);
        }
        const btn = document.getElementById("sound-btn");
        if(btn) btn.innerText = this.muted ? "üîá ÏÇ¨Ïö¥Îìú" : "üîä ÏÇ¨Ïö¥Îìú";
      }
    }
    const soundMgr = new SoundManager();

    /* ================== Global Variables ================== */
    let scene, camera, renderer;
    let groundMesh, initialGroundPositions; // For reset
    const GROUND_SIZE = 70;
    const GROUND_SEG = 80;
    
    // Physics Rocks
    const gameRocks = [];

    // Player Excavator
    const excavator = {
      group: null, body: null, boom: null, arm: null, bucket: null,
      bucketTip: null, dirtVolume: null, cnhPlate: null,
      boomAng: 0.5, armAng: -2.0, bucketAng: 0.5,
      startPos: new THREE.Vector3(0,0,0) // Player start
    };

    // AI Excavator
    const aiExcavator = {
      group: null, body: null, boom: null, arm: null, bucket: null,
      bucketTip: null, dirtVolume: null,
      boomAng: 0.5, armAng: -2.0, bucketAng: 0.5,
      // AI States
      state: 'IDLE', // IDLE, MOVE, DIG, DUMP
      timer: 0,
      targetPos: new THREE.Vector3(10, 0, 10),
      startPos: new THREE.Vector3(-10, 0, -10)
    };

    const inputs = { fwd:0, turn:0, rot:0, boom:0, arm:0, bucket:0 };
    const SPEED = { move: 0.1, turn: 0.02, joint: 0.025 };
    
    const particles = [];
    const gameState = { dirtLoad: 0, hasDug: false, hasDumped: false };

    // Physics helper
    const downRay = new THREE.Raycaster();
    const downDir = new THREE.Vector3(0, -1, 0);
    
    // Missions
    const missions = [
      { id:1, text:"F ÌÇ§Î•º ÎàåÎü¨ ÌùôÏùÑ Í∞ÄÎìù ÌååÎ≥¥ÏÑ∏Ïöî!", check:()=>gameState.hasDug && gameState.dirtLoad > 1.5, completed:false },
      { id:2, text:"R ÌÇ§Î•º ÎàåÎü¨ ÌùôÏùÑ ÏòÜÏóê Î≤ÑÎ¶¨ÏÑ∏Ïöî!", check:()=>gameState.hasDumped && gameState.dirtLoad < 0.1, completed:false },
      { id:3, text:"ÏûêÏú† ÏûëÏóÖ Î™®Îìú (Îπ®Í∞Ñ Ìè¨ÌÅ¨Î†àÏù∏Í≥º Ìï®Íªò)", check:()=>false, completed:false }
    ];
    let missionIdx = 0;

    // Camera Orbit
    const orbit = { r: 18, theta: Math.PI/4, phi: Math.PI/3.5, target: new THREE.Vector3(0,2,0), isDown:false, lastX:0, lastY:0 };

    /* ================== 3D Setup ================== */
    function init() {
      const container = document.getElementById("canvas-container");
      const w = container.clientWidth;
      const h = container.clientHeight;

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);
      scene.fog = new THREE.Fog(0x87ceeb, 40, 90);

      camera = new THREE.PerspectiveCamera(50, w/h, 0.1, 500);
      
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(w, h);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      container.appendChild(renderer.domElement);

      // Lights
      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
      scene.add(hemiLight);

      const dirLight = new THREE.DirectionalLight(0xfffae0, 1.2);
      dirLight.position.set(20, 40, 20);
      dirLight.castShadow = true;
      dirLight.shadow.mapSize.set(2048, 2048);
      scene.add(dirLight);

      createGround();
      // Player (Yellow)
      buildExcavatorModel(excavator, 0xffb300, new THREE.Vector3(0,0,0));
      // AI (Red)
      buildExcavatorModel(aiExcavator, 0xdd2222, aiExcavator.startPos);
      
      createEnvironment();
      setupEvents();
      setupUI();

      updateCamera();
      animate();
    }

    function createGround() {
      const geo = new THREE.PlaneGeometry(GROUND_SIZE, GROUND_SIZE, GROUND_SEG, GROUND_SEG);
      geo.rotateX(-Math.PI/2);
      
      const pos = geo.attributes.position;
      const vertexCount = pos.count;
      
      initialGroundPositions = new Float32Array(pos.array.length);
      const colors = new Float32Array(vertexCount * 3);
      const colAttr = new THREE.BufferAttribute(colors, 3);
      geo.setAttribute('color', colAttr);

      const cBase = new THREE.Color(0x8d6e63);
      const cGrass = new THREE.Color(0x558b2f);
      const cDark = new THREE.Color(0x5d4037);

      for(let i=0; i<vertexCount; i++) {
        const x = pos.getX(i);
        const z = pos.getZ(i);
        
        let y = (Math.sin(x*0.05)*Math.cos(z*0.05)) * 2; 
        y += Math.sin(x*0.15 + z*0.1) * 0.5;
        const dist = Math.sqrt(x*x + z*z);
        if(dist < 8) y *= (dist/8);

        pos.setY(i, y);
        initialGroundPositions[i*3] = x;
        initialGroundPositions[i*3+1] = y;
        initialGroundPositions[i*3+2] = z;

        let c = cBase.clone();
        if(y > 0.5) c.lerp(cGrass, Math.min((y-0.5)*0.5, 1));
        else if(y < -0.5) c.lerp(cDark, 0.5);
        c.offsetHSL(0, 0, (Math.random()-0.5)*0.05);
        colAttr.setXYZ(i, c.r, c.g, c.b);
      }
      geo.computeVertexNormals();
      const mat = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.9, metalness: 0.1 });
      groundMesh = new THREE.Mesh(geo, mat);
      groundMesh.receiveShadow = true;
      scene.add(groundMesh);
    }

    // Generic Builder for multiple Excavators
    function buildExcavatorModel(targetObj, colorHex, startPos) {
      const mBody = new THREE.MeshStandardMaterial({ color: colorHex, roughness: 0.2, metalness: 0.3 });
      const mDark = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });
      const mMetal = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.3, metalness: 0.8 });
      const mBucket = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.7, metalness: 0.4 });
      const mGlass = new THREE.MeshStandardMaterial({ color: 0x88ccff, roughness: 0.1, metalness: 0.9, opacity: 0.4, transparent: true });

      targetObj.group = new THREE.Group();
      targetObj.group.position.copy(startPos);
      scene.add(targetObj.group);

      const trackGroup = new THREE.Group();
      targetObj.group.add(trackGroup);
      const underFrame = new THREE.Mesh(new THREE.BoxGeometry(3, 0.5, 2), mDark);
      underFrame.position.y = 0.6;
      trackGroup.add(underFrame);

      function createTrack(z) {
        const tg = new THREE.Group();
        tg.position.set(0, 0.5, z);
        const tread = new THREE.Mesh(new THREE.BoxGeometry(5.2, 0.8, 0.9), mDark);
        tg.add(tread);
        const wheelGeo = new THREE.CylinderGeometry(0.35, 0.35, 1, 16);
        wheelGeo.rotateX(Math.PI/2);
        const w1 = new THREE.Mesh(wheelGeo, mMetal); w1.position.x = 2.2;
        const w2 = new THREE.Mesh(wheelGeo, mMetal); w2.position.x = -2.2;
        tg.add(w1, w2);
        return tg;
      }
      trackGroup.add(createTrack(1.2));
      trackGroup.add(createTrack(-1.2));

      targetObj.body = new THREE.Group();
      targetObj.body.position.y = 1.3;
      targetObj.group.add(targetObj.body);

      const deck = new THREE.Mesh(new THREE.BoxGeometry(3.5, 1.2, 3.2), mBody);
      deck.position.set(-0.2, 0.6, 0);
      deck.castShadow = true;
      targetObj.body.add(deck);

      // Cab
      const cabGroup = new THREE.Group();
      cabGroup.position.set(0.5, 1.4, 0.8);
      targetObj.body.add(cabGroup);
      const cabFrame = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.6, 1.2), mBody);
      cabGroup.add(cabFrame);
      const winF = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.2, 1.0), mGlass); winF.position.x = 0.6;
      cabGroup.add(winF);

      // CNH Plate (Only for player for now, or both)
      if(colorHex === 0xffb300) {
        const cTex = createCnhTexture();
        const cMat = new THREE.MeshBasicMaterial({ map: cTex, side: THREE.DoubleSide });
        targetObj.cnhPlate = new THREE.Mesh(new THREE.PlaneGeometry(2.5, 0.8), cMat);
        targetObj.cnhPlate.position.set(-0.2, 2.5, 0);
        targetObj.body.add(targetObj.cnhPlate);
      }

      targetObj.boom = new THREE.Group();
      targetObj.boom.position.set(1.2, 0.8, -0.5);
      targetObj.body.add(targetObj.boom);

      const boomLower = new THREE.Mesh(new THREE.BoxGeometry(0.6, 2.8, 0.5), mBody);
      boomLower.position.set(0, 1.4, 0);
      boomLower.rotation.x = -0.2;
      boomLower.castShadow = true;
      const boomUpper = new THREE.Mesh(new THREE.BoxGeometry(0.55, 2.5, 0.5), mBody);
      boomUpper.position.set(0, 3.5, 0.5);
      boomUpper.rotation.x = 0.5;
      targetObj.boom.add(boomLower, boomUpper);

      targetObj.arm = new THREE.Group();
      targetObj.arm.position.set(0, 4.6, 1.2);
      targetObj.boom.add(targetObj.arm);
      const armGeo = new THREE.Mesh(new THREE.BoxGeometry(0.45, 2.8, 0.4), mBody);
      armGeo.position.set(0, -1.2, 0);
      armGeo.castShadow = true;
      targetObj.arm.add(armGeo);

      targetObj.bucket = new THREE.Group();
      targetObj.bucket.position.set(0, -2.6, 0);
      targetObj.arm.add(targetObj.bucket);
      const bMain = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.9), mBucket);
      bMain.position.set(0.2, -0.3, 0);
      bMain.castShadow = true;
      targetObj.bucket.add(bMain);
      const toothGeo = new THREE.ConeGeometry(0.06, 0.4, 4);
      toothGeo.rotateZ(-Math.PI/2);
      for(let i=0; i<4; i++) {
        const t = new THREE.Mesh(toothGeo, mMetal);
        t.position.set(0.65, -0.6, (i-1.5)*0.22);
        targetObj.bucket.add(t);
      }

      targetObj.dirtVolume = new THREE.Mesh(new THREE.DodecahedronGeometry(0.4), new THREE.MeshStandardMaterial({ color: 0x5d4037, roughness: 1 }));
      targetObj.dirtVolume.position.set(0.3, -0.2, 0);
      targetObj.dirtVolume.scale.set(0,0,0);
      targetObj.bucket.add(targetObj.dirtVolume);

      targetObj.bucketTip = new THREE.Object3D();
      targetObj.bucketTip.position.set(0.7, -0.7, 0);
      targetObj.bucket.add(targetObj.bucketTip);
    }

    function createCnhTexture() {
      const c = document.createElement("canvas");
      c.width = 256; c.height = 64;
      const ctx = c.getContext("2d");
      ctx.fillStyle = "#111"; ctx.fillRect(0,0,256,64);
      ctx.strokeStyle = "#ffd700"; ctx.lineWidth = 3; ctx.strokeRect(2,2,252,60);
      ctx.font = "bold 24px sans-serif";
      ctx.fillStyle = "#ffd700"; ctx.textAlign = "center";
      ctx.fillText("Ïª¥ÎÑ∑ÌïòÏö∞Ïä§", 128, 28);
      ctx.font = "12px sans-serif";
      ctx.fillStyle = "#88ccff";
      ctx.fillText("cnh.bulgukto.or.kr", 128, 50);
      return new THREE.CanvasTexture(c);
    }

    function createEnvironment() {
      const mRock = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.9 });
      const rockGeo = new THREE.DodecahedronGeometry(1);
      for(let i=0; i<15; i++) {
        const scale = 0.3 + Math.random() * 0.4;
        const mesh = new THREE.Mesh(rockGeo, mRock);
        mesh.scale.set(scale, scale, scale);
        const angle = Math.random() * Math.PI * 2;
        const dist = 10 + Math.random() * 20;
        mesh.position.set(Math.cos(angle)*dist, 5 + Math.random()*5, Math.sin(angle)*dist);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        scene.add(mesh);
        gameRocks.push({
          mesh: mesh, radius: scale, velocity: new THREE.Vector3(0,0,0), startPos: mesh.position.clone()
        });
      }
    }

    function resetGame() {
      inputs.fwd=0; inputs.turn=0; inputs.rot=0; inputs.boom=0; inputs.arm=0; inputs.bucket=0;
      
      // Reset Player
      excavator.group.position.set(0,0,0);
      excavator.group.rotation.set(0,0,0);
      excavator.body.rotation.set(0,0,0);
      excavator.boomAng = 0.5; excavator.armAng = -2.0; excavator.bucketAng = 0.5;
      gameState.dirtLoad = 0;
      if(excavator.dirtVolume) excavator.dirtVolume.scale.set(0,0,0);

      // Reset AI
      aiExcavator.group.position.copy(aiExcavator.startPos);
      aiExcavator.group.rotation.set(0,0,0);
      aiExcavator.body.rotation.set(0,0,0);
      aiExcavator.state = 'IDLE'; aiExcavator.timer = 0;
      
      if(groundMesh && initialGroundPositions) {
        const pos = groundMesh.geometry.attributes.position;
        for(let i=0; i<initialGroundPositions.length; i++) pos.array[i] = initialGroundPositions[i];
        pos.needsUpdate = true;
        groundMesh.geometry.computeVertexNormals();
      }
      gameRocks.forEach(r => {
        r.mesh.position.copy(r.startPos);
        r.velocity.set(0,0,0);
        r.mesh.rotation.set(0,0,0);
      });
      showToast("Í≤åÏûÑ Î∞è AIÍ∞Ä Ï¥àÍ∏∞ÌôîÎêòÏóàÏäµÎãàÎã§.");
    }

    function updateRockPhysics() {
       const down = new THREE.Vector3(0,-1,0);
       const trackPos = excavator.group.position.clone();
       const bucketPos = new THREE.Vector3();
       if(excavator.bucket) excavator.bucket.getWorldPosition(bucketPos);
       
       gameRocks.forEach(r => {
         r.velocity.y -= 0.015;
         r.velocity.multiplyScalar(0.98);
         r.mesh.position.add(r.velocity);
         
         downRay.set(new THREE.Vector3(r.mesh.position.x, 20, r.mesh.position.z), down);
         const hits = downRay.intersectObject(groundMesh);
         if(hits.length > 0) {
           const h = hits[0].point.y;
           if(r.mesh.position.y < h + r.radius) {
             r.mesh.position.y = h + r.radius;
             r.velocity.y *= -0.3; r.velocity.x *= 0.8; r.velocity.z *= 0.8;
           }
         }
         
         const dTrack = new THREE.Vector2(r.mesh.position.x - trackPos.x, r.mesh.position.z - trackPos.z);
         if(dTrack.length() < 2.5 + r.radius) {
            const pushDir = dTrack.normalize();
            r.velocity.x += pushDir.x * 0.1; r.velocity.z += pushDir.y * 0.1;
         }
         const distBucket = r.mesh.position.distanceTo(bucketPos);
         if(distBucket < 1.3 + r.radius) {
            const pushDir = new THREE.Vector3().subVectors(r.mesh.position, bucketPos).normalize();
            r.velocity.add(pushDir.multiplyScalar(0.15));
         }
         
         r.velocity.clampLength(0, 0.8);
         r.mesh.rotation.x += r.velocity.z * 0.5;
         r.mesh.rotation.z -= r.velocity.x * 0.5;
       });
    }

    // AI Logic Loop
    function updateAI() {
      if(!aiExcavator.group) return;
      
      const ai = aiExcavator;
      ai.timer++;

      // Simple Ground Following for AI
      const down = new THREE.Vector3(0,-1,0);
      const origin = ai.group.position.clone(); origin.y = 50;
      downRay.set(origin, down);
      const hits = downRay.intersectObject(groundMesh);
      if(hits.length > 0) {
        ai.group.position.y += (hits[0].point.y - ai.group.position.y) * 0.2;
      }

      // State Machine
      switch(ai.state) {
        case 'IDLE':
          if(ai.timer > 60) {
            // Pick random target
            const angle = Math.random() * Math.PI * 2;
            const dist = 5 + Math.random() * 15;
            ai.targetPos.set(Math.cos(angle)*dist, 0, Math.sin(angle)*dist);
            ai.state = 'MOVE';
            ai.timer = 0;
          }
          break;
          
        case 'MOVE':
          const dx = ai.targetPos.x - ai.group.position.x;
          const dz = ai.targetPos.z - ai.group.position.z;
          const distToTarget = Math.sqrt(dx*dx + dz*dz);
          
          if(distToTarget < 2.0) {
            ai.state = 'DIG'; ai.timer = 0;
          } else {
            // Rotate towards target
            const targetRot = Math.atan2(-dz, dx); // Simple heading
            // Smooth rotation
            let rotDiff = targetRot - ai.group.rotation.y;
            while(rotDiff > Math.PI) rotDiff -= Math.PI*2;
            while(rotDiff < -Math.PI) rotDiff += Math.PI*2;
            ai.group.rotation.y += rotDiff * 0.05;
            
            // Move forward
            const speed = 0.06;
            ai.group.position.x += Math.cos(-ai.group.rotation.y) * speed;
            ai.group.position.z += Math.sin(-ai.group.rotation.y) * speed;
            
            // Dozing effect for AI too
            if(hits.length > 0 && hits[0].point.y > ai.group.position.y + 0.5) {
               deformGround(hits[0].point, -0.1);
               spawnDust(hits[0].point);
            }
          }
          break;
          
        case 'DIG':
          // Animation sequence
          if(ai.timer < 50) {
            // Prepare
            ai.boomAng = THREE.MathUtils.lerp(ai.boomAng, 1.2, 0.05);
            ai.armAng = THREE.MathUtils.lerp(ai.armAng, -2.0, 0.05);
            ai.bucketAng = THREE.MathUtils.lerp(ai.bucketAng, -0.5, 0.05);
          } else if (ai.timer < 100) {
            // Dig down
            ai.boomAng = THREE.MathUtils.lerp(ai.boomAng, 0.2, 0.05);
            ai.armAng = THREE.MathUtils.lerp(ai.armAng, -1.0, 0.05);
          } else if (ai.timer < 150) {
            // Scoop
            ai.bucketAng = THREE.MathUtils.lerp(ai.bucketAng, 1.2, 0.1);
            if(ai.timer === 120) {
               // Effect
               const tip = new THREE.Vector3();
               ai.bucketTip.getWorldPosition(tip);
               deformGround(tip, -0.2);
               spawnDust(tip);
               ai.dirtVolume.scale.set(1,1,1); // Show dirt
            }
          } else {
            ai.state = 'DUMP'; ai.timer = 0;
          }
          break;
          
        case 'DUMP':
          if(ai.timer < 60) {
            // Lift and rotate body
            ai.boomAng = THREE.MathUtils.lerp(ai.boomAng, 1.0, 0.05);
            ai.armAng = THREE.MathUtils.lerp(ai.armAng, -1.5, 0.05);
            ai.body.rotation.y += 0.02; 
          } else if (ai.timer < 100) {
            // Dump
            ai.bucketAng = THREE.MathUtils.lerp(ai.bucketAng, -0.5, 0.1);
            if(ai.timer === 80) {
               ai.dirtVolume.scale.set(0,0,0);
               const tip = new THREE.Vector3();
               ai.bucketTip.getWorldPosition(tip);
               spawnDust(tip);
               deformGround(tip, 0.3); // Mound
            }
          } else {
            ai.state = 'IDLE'; ai.timer = 0;
          }
          break;
      }
      
      // Update AI Joint Meshes
      ai.boom.rotation.x = ai.boomAng;
      ai.arm.rotation.x = ai.armAng;
      ai.bucket.rotation.x = ai.bucketAng;
    }

    function updatePhysics() {
      // 1. Move Tracks with Dozing
      if(Math.abs(inputs.fwd) > 0 || Math.abs(inputs.turn) > 0) {
        let move = inputs.fwd * SPEED.move;
        const rot = inputs.turn * SPEED.turn;
        excavator.group.rotation.y += rot;
        const dirX = Math.cos(-excavator.group.rotation.y); 
        const dirZ = Math.sin(-excavator.group.rotation.y);

        if(inputs.fwd > 0 && groundMesh) {
            const frontPos = excavator.group.position.clone().add(new THREE.Vector3(dirX, 0, dirZ).multiplyScalar(2.0));
            frontPos.y = 20;
            downRay.set(frontPos, downDir);
            const hits = downRay.intersectObject(groundMesh);
            if(hits.length > 0) {
                const frontH = hits[0].point.y;
                const myH = excavator.group.position.y;
                if(frontH > myH + 0.4) {
                    deformGround(hits[0].point, -0.15);
                    spawnDust(hits[0].point);
                    move *= 0.4;
                }
            }
        }
        excavator.group.position.x += dirX * move;
        excavator.group.position.z += dirZ * move;
      }

      // 1.5 Ground Collision
      if(groundMesh) {
        const origin = excavator.group.position.clone(); origin.y = 50; 
        downRay.set(origin, downDir);
        const intersects = downRay.intersectObject(groundMesh);
        if(intersects.length > 0) {
          const groundHeight = intersects[0].point.y;
          const diff = groundHeight - excavator.group.position.y;
          if(diff > 0.8) excavator.group.position.y += diff * 0.02;
          else excavator.group.position.y += diff * 0.2;
        } else {
          excavator.group.position.y = Math.max(0, excavator.group.position.y);
        }
      }

      // 2. Rotate Body
      excavator.body.rotation.y -= inputs.rot * SPEED.turn;

      // 3. Move Arms
      excavator.boomAng += inputs.boom * SPEED.joint;
      excavator.armAng += inputs.arm * SPEED.joint;
      excavator.bucketAng += inputs.bucket * SPEED.joint;

      excavator.boomAng = Math.max(-0.2, Math.min(1.5, excavator.boomAng));
      excavator.armAng = Math.max(-2.5, Math.min(-0.2, excavator.armAng));
      excavator.bucketAng = Math.max(-0.5, Math.min(1.5, excavator.bucketAng));

      excavator.boom.rotation.x = excavator.boomAng;
      excavator.arm.rotation.x = excavator.armAng;
      excavator.bucket.rotation.x = excavator.bucketAng;

      // 4. Digging Logic
      const tipPos = new THREE.Vector3();
      excavator.bucketTip.getWorldPosition(tipPos);

      if(inputs.bucket > 0 && tipPos.y < 0.2) {
        if(gameState.dirtLoad < 2.0) { 
          gameState.dirtLoad += 0.02; 
          deformGround(tipPos, -0.08); 
          soundMgr.playDig();
          spawnDust(tipPos);
          gameState.hasDug = true;
        }
      }

      if(inputs.bucket < 0 && gameState.dirtLoad > 0) {
        gameState.dirtLoad -= 0.02;
        deformGround(tipPos, 0.4); 
        spawnDust(tipPos);
        gameState.hasDumped = true;
      }
      
      if(excavator.dirtVolume) {
        const s = Math.max(0, Math.min(1.8, gameState.dirtLoad));
        excavator.dirtVolume.scale.set(s,s,s);
      }
      
      const fill = document.getElementById("load-fill");
      if(fill) fill.style.height = Math.min(100, (gameState.dirtLoad / 2.0) * 100) + "%";

      const m = missions[missionIdx];
      if(m && !m.completed && m.check()) {
        m.completed = true;
        soundMgr.playSuccess();
        showToast("ÎØ∏ÏÖò ÏôÑÎ£å: " + m.text);
        missionIdx++;
        updateMissionUI();
      }

      const isActive = Object.values(inputs).some(v=>v!==0);
      soundMgr.setRPM(isActive, (inputs.bucket > 0 && tipPos.y < 0.2));

      // 5. Physics Update
      updateRockPhysics();
      updateAI();
    }

    function deformGround(pos, delta) {
      const positions = groundMesh.geometry.attributes.position;
      const local = groundMesh.worldToLocal(pos.clone());
      const radius = 1.5;
      let modified = false;
      for(let i=0; i<positions.count; i++) {
        const dx = positions.getX(i) - local.x;
        const dz = positions.getZ(i) - local.z;
        const dist = Math.sqrt(dx*dx + dz*dz);
        if(dist < radius) {
          const factor = (1 - dist/radius); 
          const oldY = positions.getY(i);
          let newY = oldY + delta * factor;
          newY = Math.max(-2, Math.min(3, newY));
          positions.setY(i, newY);
          modified = true;
        }
      }
      if(modified) {
        positions.needsUpdate = true;
        groundMesh.geometry.computeVertexNormals();
      }
    }

    function spawnDust(pos) {
      if(Math.random() > 0.3) return;
      const geo = new THREE.PlaneGeometry(0.3, 0.3);
      const mat = new THREE.MeshBasicMaterial({ color: 0xd7ccc8, opacity:0.6, transparent:true, side:THREE.DoubleSide });
      const p = new THREE.Mesh(geo, mat);
      p.position.copy(pos);
      p.position.y += 0.2;
      p.lookAt(camera.position);
      scene.add(p);
      particles.push({ mesh:p, life:1.0, dy: 0.02 });
    }

    function updateParticles() {
      for(let i=particles.length-1; i>=0; i--) {
        const p = particles[i];
        p.life -= 0.03;
        p.mesh.position.y += p.dy;
        p.mesh.lookAt(camera.position);
        p.mesh.material.opacity = p.life;
        if(p.life <= 0) {
          scene.remove(p.mesh);
          particles.splice(i,1);
        }
      }
    }

    function updateMissionUI() {
      const t = document.getElementById("mission-title");
      const tx = document.getElementById("mission-text");
      if(missionIdx < missions.length) {
        t.innerText = "MISSION " + (missionIdx+1);
        tx.innerText = missions[missionIdx].text;
      } else {
        t.innerText = "COMPLETE";
        tx.innerText = "Î™®Îì† ÎØ∏ÏÖò ÏôÑÎ£å! ÏûêÏú†Î°≠Í≤å ÏûëÏóÖÌïòÏÑ∏Ïöî.";
      }
    }

    function updateCamera() {
      if(excavator.group) {
        orbit.target.copy(excavator.group.position);
        orbit.target.y += 2.0; 
      }
      const x = orbit.target.x + orbit.r * Math.sin(orbit.phi) * Math.cos(orbit.theta);
      const y = orbit.target.y + orbit.r * Math.cos(orbit.phi);
      const z = orbit.target.z + orbit.r * Math.sin(orbit.phi) * Math.sin(orbit.theta);
      camera.position.set(x, y, z);
      camera.lookAt(orbit.target);
    }

    function animate() {
      requestAnimationFrame(animate);
      updatePhysics();
      updateParticles();
      updateCamera();
      if(excavator.cnhPlate) excavator.cnhPlate.lookAt(camera.position);
      renderer.render(scene, camera);
    }

    function setupEvents() {
      window.addEventListener("keydown", e => handleKey(e.code, 1));
      window.addEventListener("keyup", e => handleKey(e.code, 0));

      const canvas = renderer.domElement;
      canvas.addEventListener("mousedown", e => { orbit.isDown = true; orbit.lastX = e.clientX; orbit.lastY = e.clientY; });
      window.addEventListener("mouseup", () => orbit.isDown = false);
      window.addEventListener("mousemove", e => {
        if(!orbit.isDown) return;
        const dx = e.clientX - orbit.lastX;
        const dy = e.clientY - orbit.lastY;
        orbit.lastX = e.clientX; orbit.lastY = e.clientY;
        orbit.theta -= dx * 0.01;
        orbit.phi -= dy * 0.01;
        orbit.phi = Math.max(0.1, Math.min(Math.PI/2 - 0.1, orbit.phi));
      });
      canvas.addEventListener("touchstart", e => { 
        orbit.isDown = true; 
        orbit.lastX = e.touches[0].clientX; 
        orbit.lastY = e.touches[0].clientY; 
      }, {passive:false});
      canvas.addEventListener("touchend", () => orbit.isDown = false);
      canvas.addEventListener("touchmove", e => {
        if(!orbit.isDown) return;
        e.preventDefault(); 
        const dx = e.touches[0].clientX - orbit.lastX;
        const dy = e.touches[0].clientY - orbit.lastY;
        orbit.lastX = e.touches[0].clientX; 
        orbit.lastY = e.touches[0].clientY; 
        orbit.theta -= dx * 0.01;
        orbit.phi -= dy * 0.01;
        orbit.phi = Math.max(0.1, Math.min(Math.PI/2 - 0.1, orbit.phi));
      }, {passive:false});

      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      canvas.addEventListener("click", e => {
        const rect = canvas.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        if(excavator.cnhPlate) {
          const intersects = raycaster.intersectObject(excavator.cnhPlate);
          if(intersects.length > 0) window.open("http://cnh.bulgukto.or.kr/", "_blank");
        }
      });
    }

    function handleKey(code, val) {
      switch(code) {
        case "ArrowUp": inputs.fwd = val; break;
        case "ArrowDown": inputs.fwd = -val; break;
        case "ArrowLeft": inputs.turn = val; break;
        case "ArrowRight": inputs.turn = -val; break;
        case "KeyW": inputs.boom = -val; break;
        case "KeyS": inputs.boom = val; break;
        case "KeyE": inputs.arm = val; break;
        case "KeyQ": inputs.arm = -val; break;
        case "KeyF": inputs.bucket = val; break;
        case "KeyR": inputs.bucket = -val; break;
        case "KeyA": inputs.rot = val; break;
        case "KeyD": inputs.rot = -val; break;
      }
    }

    function setupUI() {
      const bind = (id, key, v) => {
        const btn = document.getElementById(id);
        if(!btn) return;
        const start = (e) => { e.preventDefault(); inputs[key] = v; btn.style.background = "#ffd700"; btn.style.color = "#000"; };
        const end = (e) => { e.preventDefault(); inputs[key] = 0; btn.style.background = ""; btn.style.color = ""; };
        btn.addEventListener("mousedown", start);
        btn.addEventListener("mouseup", end);
        btn.addEventListener("mouseleave", end);
        btn.addEventListener("touchstart", start);
        btn.addEventListener("touchend", end);
      };

      bind("btn-fwd", "fwd", 1);
      bind("btn-back", "fwd", -1);
      bind("btn-left", "turn", 1);
      bind("btn-right", "turn", -1);
      bind("btn-boom-up", "boom", -1);
      bind("btn-boom-down", "boom", 1);
      bind("btn-arm-out", "arm", 1);
      bind("btn-arm-in", "arm", -1);
      bind("btn-bucket-in", "bucket", 1);
      bind("btn-bucket-out", "bucket", -1);

      document.getElementById("start-btn").addEventListener("click", () => {
        document.getElementById("start-overlay").style.display = "none";
        soundMgr.init();
      });
      document.getElementById("start-btn").addEventListener("touchstart", () => {
        document.getElementById("start-overlay").style.display = "none";
        soundMgr.init();
      });

      document.getElementById("reset-btn").addEventListener("click", resetGame);
      document.getElementById("sound-btn").addEventListener("click", () => soundMgr.toggleMute());
      document.getElementById("guide-toggle-btn").addEventListener("click", () => {
        const g = document.getElementById("instructions");
        g.style.display = (g.style.display === "none") ? "block" : "none";
      });
      document.getElementById("share-btn").addEventListener("click", () => {
        const url = window.location.href;
        const t = document.createElement("textarea");
        t.value = url;
        document.body.appendChild(t);
        t.select();
        try { document.execCommand('copy'); showToast("Ï£ºÏÜåÍ∞Ä Î≥µÏÇ¨ÎêòÏóàÏäµÎãàÎã§!"); } catch(e){}
        document.body.removeChild(t);
      });
    }

    window.onload = init;
    window.onresize = () => {
      const c = document.getElementById("canvas-container");
      camera.aspect = c.clientWidth / c.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(c.clientWidth, c.clientHeight);
    };
  </script>
</body>
</html>
