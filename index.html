<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>REAL EXCAVATOR V48 LITE - Terrain Dig</title>
  <meta
    name="viewport"
    content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"
  />
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #000;
      font-family: "Noto Sans KR", system-ui, -apple-system, BlinkMacSystemFont,
        sans-serif;
    }

    /* ì „ì²´ ê²Œì„ ë˜í¼ (iframe ì•ˆì—ì„œë„ ê½‰ ì°¨ê²Œ) */
    #excavator-wrapper {
      position: relative;
      width: 100%;
      height: 100vh; /* iframe ì•ˆì˜ ë†’ì´ë§Œí¼ ê½‰ ì±„ì›€ */
      background: #050505;
      overflow: hidden;
      box-sizing: border-box;
    }

    #canvas-container {
      position: absolute;
      inset: 0;
    }
    #ui-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    /* ì‹œì‘ ì˜¤ë²„ë ˆì´ */
    #start-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 10;
      color: #fff;
      pointer-events: auto;
    }
    #start-overlay h1 {
      color: #ffd700;
      font-size: 2.4rem;
      margin-bottom: 10px;
      text-shadow: 0 0 20px #ffd700;
      text-align: center;
    }
    #start-overlay p {
      margin-bottom: 20px;
      color: #ccc;
      text-align: center;
      font-size: 0.95rem;
    }
    #start-btn {
      padding: 14px 36px;
      font-size: 1.2rem;
      font-weight: 900;
      color: #111;
      background: linear-gradient(135deg, #ffd700 0%, #ffa500 100%);
      border: none;
      border-radius: 999px;
      cursor: pointer;
      box-shadow: 0 0 18px rgba(255, 165, 0, 0.6);
      text-transform: uppercase;
      letter-spacing: 2px;
    }
    #start-btn:active {
      transform: scale(0.96);
      box-shadow: 0 0 8px rgba(255, 215, 0, 0.7);
    }

    /* ìƒë‹¨ ì¢Œì¸¡ ë²„íŠ¼ë“¤ */
    #top-left-buttons {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      gap: 6px;
      pointer-events: auto;
      flex-wrap: wrap;
      z-index: 5;
    }
    .top-btn {
      padding: 5px 10px;
      font-size: 0.7rem;
      border-radius: 999px;
      border: 1px solid #ffd700;
      background: rgba(0, 0, 0, 0.75);
      color: #ffd700;
      cursor: pointer;
      white-space: nowrap;
    }
    .top-btn:active {
      transform: scale(0.95);
      background: #ffd700;
      color: #000;
    }

    /* ë¯¸ì…˜ ë°•ìŠ¤ (ì•½ê°„ ì•„ë˜ë¡œ) */
    #mission-box {
      position: absolute;
      top: 60px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid #ffd700;
      border-radius: 12px;
      padding: 8px 18px;
      color: #fff;
      pointer-events: auto;
      min-width: 220px;
      font-size: 0.8rem;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.5);
      text-align: center;
      z-index: 4;
    }
    #mission-title {
      color: #ffd700;
      font-size: 0.7rem;
      font-weight: bold;
      letter-spacing: 2px;
      margin-bottom: 3px;
    }
    #mission-text {
      font-size: 0.85rem;
      font-weight: bold;
      text-shadow: 1px 1px 2px #000;
    }

    /* ë²„í‚· ë¡œë“œ ê²Œì´ì§€ */
    #load-gauge-container {
      position: absolute;
      top: 60px;
      right: 10px;
      width: 22px;
      height: 140px;
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid #777;
      border-radius: 8px;
      overflow: hidden;
      z-index: 4;
    }
    #load-fill {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 0%;
      background: linear-gradient(to top, #5d4037, #8d6e63);
      transition: height 0.1s;
    }
    #load-label {
      position: absolute;
      top: 205px;
      right: 6px;
      color: #fff;
      font-size: 0.6rem;
      font-weight: bold;
      text-shadow: 1px 1px 2px #000;
      text-align: center;
      width: 40px;
      z-index: 4;
    }

    /* ì¡°ì‘ ê°€ì´ë“œ */
    #instructions {
      position: absolute;
      left: 10px;
      bottom: 90px;
      background: linear-gradient(90deg, rgba(0, 0, 0, 0.8), transparent);
      color: #fff;
      padding: 10px 14px;
      border-radius: 10px;
      border-left: 4px solid #ffd700;
      max-width: 260px;
      font-size: 0.75rem;
      pointer-events: auto;
      z-index: 4;
    }
    #instructions h2 {
      margin: 0 0 6px 0;
      font-size: 0.9rem;
      color: #ffd700;
      text-shadow: 2px 2px 2px #000;
    }
    #instructions ul {
      list-style: none;
      padding-left: 10px;
      margin: 0;
    }
    #instructions li {
      margin-bottom: 2px;
    }
    .key {
      display: inline-block;
      background: #333;
      border-radius: 4px;
      padding: 1px 4px;
      border: 1px solid #555;
      font-family: monospace;
      font-size: 0.7rem;
      margin-right: 2px;
    }
    .key.special {
      color: #ffd700;
      border-color: #ffd700;
    }
    .tip {
      color: #ffd700;
      margin-top: 4px;
    }

    /* ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ëŸ¬ â€“ ì‚´ì§ ìœ„ë¡œ */
    #controls-container {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 20px; /* ìœ„ë¡œ 20px ì˜¬ë¦¼ */
      padding: 8px 10px;
      display: flex;
      justify-content: space-between;
      pointer-events: auto;
      background: linear-gradient(0deg, rgba(0, 0, 0, 0.9), transparent);
      z-index: 3;
      box-sizing: border-box;
    }
    .control-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      background: rgba(40, 40, 40, 0.8);
      padding: 6px 8px;
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.15);
    }
    .label {
      color: #aaa;
      font-size: 0.7rem;
      font-weight: bold;
      margin-bottom: 3px;
      letter-spacing: 1px;
    }
    .btn-row {
      display: flex;
      gap: 6px;
      margin: 2px 0;
    }
    .ctrl-btn {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 1px solid #555;
      background: radial-gradient(circle at 30% 30%, #444, #111);
      color: #eee;
      font-size: 0.9rem;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5),
        inset 0 1px 1px rgba(255, 255, 255, 0.2);
      -webkit-tap-highlight-color: transparent;
    }
    .ctrl-btn:active {
      background: #ffd700;
      color: #000;
      transform: scale(0.96);
    }

    @media (max-width: 768px) {
      #instructions {
        display: none;
      }
      .ctrl-btn {
        width: 34px;
        height: 34px;
        font-size: 0.8rem;
      }
      .control-group {
        padding: 4px 6px;
      }
    }
  </style>

  <!-- three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
</head>
<body>
  <div id="excavator-wrapper">
    <div id="start-overlay">
      <h1>REAL EXCAVATOR V48 LITE</h1>
      <p>
        F: Dig (ë•…íŒŒê¸°) | R: Dump (ë²„ë¦¬ê¸°)<br />Arrows: Move | WASD + QE: Arm
        Control
      </p>
      <button id="start-btn" type="button">ì‘ì—… ì‹œì‘</button>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
      <div id="top-left-buttons">
        <button id="reset-btn" class="top-btn" type="button">ì´ˆê¸°í™”</button>
        <button id="sound-btn" class="top-btn" type="button">ğŸ”Š ì‚¬ìš´ë“œ</button>
        <button id="guide-toggle-btn" class="top-btn" type="button">
          ê°€ì´ë“œ ìˆ¨ê¸°ê¸°
        </button>
        <button id="share-btn" class="top-btn" type="button">ê³µìœ </button>
      </div>

      <div id="mission-box">
        <div id="mission-title">MISSION 1</div>
        <div id="mission-text">
          F í‚¤ë¥¼ ê¾¹ ëˆŒëŸ¬ ë•…ì„ ê¹Šê²Œ íŒŒë³´ì„¸ìš”! (ë²„í‚· ë‹´ê¸°)
        </div>
      </div>

      <div id="load-gauge-container"><div id="load-fill"></div></div>
      <div id="load-label">DIRT</div>

      <div id="instructions">
        <h2>ì¡°ì‘ ê°€ì´ë“œ (V48)</h2>
        <ul>
          <li>
            <span class="key">W</span><span class="key">S</span> : ë¶
            (ë‚´ë¦¬ê¸°/ì˜¬ë¦¬ê¸°)
          </li>
          <li>
            <span class="key">Q</span><span class="key">E</span> : ì•”
            (í´ê¸°/ì ‘ê¸°)
          </li>
          <li>
            <span class="key">A</span><span class="key">D</span> : ë³¸ì²´ íšŒì „
          </li>
          <li>
            <span class="key special">F</span> : <b>ë•…íŒŒê¸° (Dig)</b>
          </li>
          <li><span class="key">R</span> : í™ë²„ë¦¬ê¸° (Dump)</li>
          <li><span class="key">ë°©í–¥í‚¤</span> : ì£¼í–‰</li>
          <li class="tip">ğŸ’¡ ë§ˆìš°ìŠ¤ë¡œ í™”ë©´ì„ ëŒë ¤ë³´ì„¸ìš”!</li>
        </ul>
      </div>

      <div id="controls-container">
        <div class="control-group">
          <div class="label">DRIVE</div>
          <div class="btn-row">
            <button class="ctrl-btn" id="btn-fwd" type="button">â–²</button>
          </div>
          <div class="btn-row">
            <button class="ctrl-btn" id="btn-left" type="button">â—€</button>
            <button class="ctrl-btn" id="btn-back" type="button">â–¼</button>
            <button class="ctrl-btn" id="btn-right" type="button">â–¶</button>
          </div>
        </div>

        <div class="control-group">
          <div class="label">HYDRAULICS</div>
          <div class="btn-row">
            <button class="ctrl-btn" id="btn-boom-up" type="button">
              ë¶(S)â†‘
            </button>
            <button class="ctrl-btn" id="btn-boom-down" type="button">
              ë¶(W)â†“
            </button>
          </div>
          <div class="btn-row">
            <button class="ctrl-btn" id="btn-arm-out" type="button">
              ì•”(E)â†‘
            </button>
            <button class="ctrl-btn" id="btn-arm-in" type="button">
              ì•”(Q)â†“
            </button>
          </div>
          <div class="btn-row">
            <button class="ctrl-btn" id="btn-bucket-in" type="button">
              ë•…íŒŒê¸°(F)
            </button>
            <button class="ctrl-btn" id="btn-bucket-out" type="button">
              ë²„ë¦¬ê¸°(R)
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    /* ================== ì‚¬ìš´ë“œ ================== */
    class SoundManager {
      constructor() {
        this.ctx = null;
        this.isInit = false;
        this.lastDigTime = 0;
        this.engineOsc = null;
        this.engineGain = null;
        this.muted = false;
      }
      init() {
        if (this.isInit) return;
        const AC = window.AudioContext || window.webkitAudioContext;
        try {
          this.ctx = new AC();
        } catch (e) {
          console.warn("AudioContext ì‹¤íŒ¨", e);
          return;
        }
        this.engineOsc = this.ctx.createOscillator();
        this.engineOsc.type = "sawtooth";
        this.engineOsc.frequency.value = 40;
        this.engineGain = this.ctx.createGain();
        this.engineGain.gain.value = 0.05;
        const f = this.ctx.createBiquadFilter();
        f.type = "lowpass";
        f.frequency.value = 250;
        this.engineOsc.connect(f);
        f.connect(this.engineGain);
        this.engineGain.connect(this.ctx.destination);
        this.engineOsc.start();
        this.isInit = true;
      }
      setRPM(active, load) {
        if (!this.isInit) return;
        const t = this.ctx.currentTime;
        const targetFreq = active ? (load ? 55 : 60) : 40;
        const baseVol = active ? 0.1 : 0.05;
        const targetVol = this.muted ? 0 : baseVol;
        this.engineOsc.frequency.setTargetAtTime(targetFreq, t, 0.2);
        this.engineGain.gain.setTargetAtTime(targetVol, t, 0.2);
      }
      playDig() {
        if (!this.isInit || this.muted) return;
        const now = this.ctx.currentTime;
        if (now - this.lastDigTime < 0.15) return;
        this.lastDigTime = now;
        const buf = this.ctx.createBuffer(1, 22050, 44100);
        const d = buf.getChannelData(0);
        for (let i = 0; i < 22050; i++) {
          d[i] = (Math.random() * 2 - 1) * Math.exp(-i / 800);
        }
        const src = this.ctx.createBufferSource();
        src.buffer = buf;
        const g = this.ctx.createGain();
        g.gain.value = 0.4;
        const f = this.ctx.createBiquadFilter();
        f.type = "lowpass";
        f.frequency.value = 300;
        src.connect(f);
        f.connect(g);
        g.connect(this.ctx.destination);
        src.start();
      }
      playComplete() {
        if (!this.isInit || this.muted) return;
        const osc = this.ctx.createOscillator();
        osc.type = "sine";
        osc.frequency.setValueAtTime(600, this.ctx.currentTime);
        osc.frequency.linearRampToValueAtTime(
          1200,
          this.ctx.currentTime + 0.1
        );
        const g = this.ctx.createGain();
        g.gain.value = 0.3;
        g.gain.exponentialRampToValueAtTime(
          0.01,
          this.ctx.currentTime + 0.4
        );
        osc.connect(g);
        g.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.4);
      }
      toggleMute() {
        this.muted = !this.muted;
        if (this.isInit && this.engineGain) {
          const t = this.ctx.currentTime;
          const targetVol = this.muted ? 0 : 0.05;
          this.engineGain.gain.setTargetAtTime(targetVol, t, 0.1);
        }
        const btn = document.getElementById("sound-btn");
        if (btn) btn.textContent = this.muted ? "ğŸ”‡ ì‚¬ìš´ë“œ" : "ğŸ”Š ì‚¬ìš´ë“œ";
      }
    }
    const soundMgr = new SoundManager();

    /* ================== ì „ì—­ ìƒíƒœ ================== */
    let scene, camera, renderer;
    const excavator = {
      group: null,
      body: null,
      boom: null,
      arm: null,
      bucket: null,
      dirtVolume: null,
      bucketTip: null,
      cnhPlate: null,
      boomAng: 0.3,
      armAng: -1.7,
      bucketAng: 0.4,
    };
    const inputs = { fwd: 0, turn: 0, rot: 0, boom: 0, arm: 0, bucket: 0 };
    const SPEED = { move: 0.12, turn: 0.02, joint: 0.02 };

    const particles = [];
    const gameState = { dirtLoad: 0, hasDug: false, hasDumped: false };
    let lastTipWorld = null;

    const missions = [
      {
        id: 1,
        text: "F í‚¤ë¥¼ ê¾¹ ëˆŒëŸ¬ ë•…ì„ ê¹Šê²Œ íŒŒë³´ì„¸ìš”! (ë²„í‚· ë‹´ê¸°)",
        check: () => gameState.hasDug,
        complete: false,
        progress: 0,
      },
      {
        id: 2,
        text: "R í‚¤ë¥¼ ëˆŒëŸ¬ í™ì„ ì˜†ì— ìŸì•„ë³´ì„¸ìš” (ë²„í‚· í´ê¸°)",
        check: () => gameState.hasDumped,
        complete: false,
        progress: 0,
      },
    ];
    let currentMissionIdx = 0;

    // ì¹´ë©”ë¼ ì˜¤ë¹„íŠ¸
    const orbit = {
      theta: Math.PI / 4,
      phi: Math.PI / 4,
      radius: 22,
      target: new THREE.Vector3(0, 1.5, 0),
      isDragging: false,
      lastX: 0,
      lastY: 0,
    };

    // ì»´ë„·í•˜ìš°ìŠ¤ í´ë¦­ìš©
    let raycaster, mouse;

    // ì§€ë©´(ë³€í˜• ê°€ëŠ¥)
    let groundMesh = null;
    let groundPositions = null;
    const GROUND_SIZE = 60;
    const GROUND_SEG = 80;

    function updateCameraOrbit() {
      const r = orbit.radius;
      const t = orbit.theta;
      const p = orbit.phi;
      const ct = Math.cos(t),
        st = Math.sin(t);
      const cp = Math.cos(p),
        sp = Math.sin(p);
      const x = orbit.target.x + r * sp * ct;
      const y = orbit.target.y + r * cp;
      const z = orbit.target.z + r * sp * st;
      camera.position.set(x, y, z);
      camera.lookAt(orbit.target);
    }

    /* ================== ì§€í˜•/í™˜ê²½ ================== */
    function createTerrain() {
    const geo = new THREE.PlaneGeometry(TERRAIN_SIZE, TERRAIN_SIZE, TERRAIN_RES, TERRAIN_RES);
    geo.rotateX(-Math.PI / 2);

    const pos = geo.attributes.position;
    const col = new THREE.Float32BufferAttribute((TERRAIN_RES + 1) * (TERRAIN_RES + 1) * 3, 3);

    // ê¸°ë³¸ ìƒ‰
    const baseC = new THREE.Color(0xC2B280);  // í™ìƒ‰
    const hillC = new THREE.Color(0x8d6e63);  // ê°ˆìƒ‰
    const shadowC = new THREE.Color(0x5d4037); // ì–´ë‘ìš´ ë¶€ë¶„

    // ëœë¤ ì–¸ë• ì„¤ì •
    const hills = [
        { x: -20, z: -10, height: 4, radius: 18 },
        { x: 15,  z: 20,  height: 3.5, radius: 15 },
        { x: 0,   z: -25, height: 5, radius: 20 },
        { x: -25, z: 10,  height: 2.5, radius: 10 },
        { x: 25,  z: -15, height: 3, radius: 12 }
    ];

    // Perlin noiseë¡œ ì „ì²´ ì§€í˜• ìì—°ìŠ¤ëŸ½ê²Œ
    function noise(nx, ny) {
        return (Math.sin(nx * 3.1 + ny * 1.7) + Math.cos(nx * 2.2 - ny * 4.3)) * 0.5;
    }

    for (let i = 0; i < pos.count; i++) {
        let x = pos.getX(i);
        let z = pos.getZ(i);

        // ê¸°ë³¸ ë…¸ì´ì¦ˆ ì§€í˜•
        let h = noise(x * 0.03, z * 0.03) * 1.2;

        // ì–¸ë• ìƒì„±
        hills.forEach(hill => {
            const dx = x - hill.x;
            const dz = z - hill.z;
            const d = Math.sqrt(dx * dx + dz * dz);

            if (d < hill.radius) {
                // ë¶€ë“œëŸ¬ìš´ ì–¸ë• ê³¡ì„ 
                const t = 1 - d / hill.radius;
                h += hill.height * (t * t);
            }
        });

        // í¬í¬ë ˆì¸ ìŠ¤í° ì§€ì—­ì€ í‰í‰í•˜ê²Œ
        if (Math.sqrt(x * x + z * z) < 8) h = 0;

        pos.setY(i, h);
        terrainData[i] = h;

        // ìƒ‰ìƒ ê·¸ë¼ë°ì´ì…˜
        let c = baseC.clone().lerp(hillC, h / 5);

        // ì–¸ë•ì´ ë†’ìœ¼ë©´ ì•½ê°„ ì–´ë‘¡ê²Œ
        if (h > 2) c = c.lerp(shadowC, 0.3);

        col.setXYZ(i, c.r, c.g, c.b);
    }

    geo.setAttribute("color", col);
    geo.computeVertexNormals();

    terrainMesh = new THREE.Mesh(geo, MATS.dirt);
    terrainMesh.receiveShadow = true;
    scene.add(terrainMesh);
}

    // ë²„í‚·ì´ ì§€ë‚˜ê°„ ê²½ë¡œ(ì„ )ë¥¼ ë”°ë¼ ì—¬ëŸ¬ ì§€ì  ë³€í˜•
    function deformGroundAlongSegment(
      p0,
      p1,
      delta,
      steps = 4,
      radius = 1.4,
      maxH = 1.8
    ) {
      if (!p0 || !p1) return;
      const pos = new THREE.Vector3();
      for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        pos.lerpVectors(p0, p1, t);
        deformGround(pos, delta, radius, maxH);
      }
    }

    function createEnvironment() {
      const coneGeo = new THREE.CylinderGeometry(0.05, 0.3, 0.6, 16);
      const coneMat = new THREE.MeshStandardMaterial({
        color: 0xff4400,
        roughness: 0.2,
      });
      const whiteMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.2,
      });
      for (let i = 0; i < 8; i++) {
        const grp = new THREE.Group();
        const base = new THREE.Mesh(coneGeo, coneMat);
        base.position.y = 0.3;
        const str = new THREE.Mesh(
          new THREE.CylinderGeometry(0.12, 0.2, 0.15, 16),
          whiteMat
        );
        str.position.y = 0.35;
        grp.add(base, str);
        const a = (i / 8) * Math.PI * 2;
        const x = Math.cos(a) * 12;
        const z = Math.sin(a) * 12;
        grp.position.set(x, 0, z);
        grp.castShadow = true;
        scene.add(grp);
      }
    }

    function createCnhTexture() {
      const c = document.createElement("canvas");
      c.width = 512;
      c.height = 128;
      const ctx = c.getContext("2d");
      if (!ctx) return null;
      ctx.fillStyle = "#111";
      ctx.fillRect(0, 0, 512, 128);
      ctx.strokeStyle = "#ffd700";
      ctx.lineWidth = 4;
      ctx.strokeRect(4, 4, 504, 120);
      ctx.font = "bold 46px sans-serif";
      ctx.fillStyle = "#ffd700";
      ctx.textAlign = "center";
      ctx.fillText("ì»´ë„·í•˜ìš°ìŠ¤", 256, 60);
      ctx.font = "24px sans-serif";
      ctx.fillStyle = "#9fd4ff";
      ctx.fillText("cnh.bulgukto.or.kr", 256, 100);
      return new THREE.CanvasTexture(c);
    }

    /* ================== í¬í¬ë ˆì¸ ================== */
    function buildExcavator() {
      const darkMat = new THREE.MeshStandardMaterial({
        color: 0x1a1a1a,
        roughness: 0.7,
      });
      const bodyMat = new THREE.MeshStandardMaterial({
        color: 0xffb300,
        roughness: 0.3,
        metalness: 0.3,
      });

      excavator.group = new THREE.Group();
      scene.add(excavator.group);

      // íŠ¸ë™
      const tracks = new THREE.Group();
      excavator.group.add(tracks);
      const trackBoxGeo = new THREE.BoxGeometry(5.5, 0.8, 1.0);
      const t1 = new THREE.Mesh(trackBoxGeo, darkMat);
      t1.position.set(0, 0.5, 1.4);
      const t2 = new THREE.Mesh(trackBoxGeo, darkMat);
      t2.position.set(0, 0.5, -1.4);
      tracks.add(t1, t2);
      const center = new THREE.Mesh(
        new THREE.BoxGeometry(3, 0.4, 2.2),
        darkMat
      );
      center.position.y = 0.7;
      excavator.group.add(center);

      // ìƒë¶€
      excavator.body = new THREE.Group();
      excavator.body.position.y = 1.4;
      excavator.group.add(excavator.body);

      const deck = new THREE.Mesh(
        new THREE.BoxGeometry(3.6, 1.0, 3.4),
        bodyMat
      );
      deck.position.set(0, 0.6, 0);
      deck.castShadow = true;
      excavator.body.add(deck);

      // ë¶
      excavator.boom = new THREE.Group();
      excavator.boom.position.set(0.6, 1.0, -0.6);
      excavator.body.add(excavator.boom);

      const boomMesh = new THREE.Mesh(
        new THREE.BoxGeometry(0.7, 4.5, 0.6),
        bodyMat
      );
      boomMesh.position.set(0, 2.25, 0);
      boomMesh.castShadow = true;
      excavator.boom.add(boomMesh);

      // ì•”
      excavator.arm = new THREE.Group();
      excavator.arm.position.set(0, 4.5, 0);
      excavator.boom.add(excavator.arm);
      const armMesh = new THREE.Mesh(
        new THREE.BoxGeometry(0.6, 3.2, 0.5),
        bodyMat
      );
      armMesh.position.set(0, -1.6, 0);
      armMesh.castShadow = true;
      excavator.arm.add(armMesh);

      // ë²„í‚·
      excavator.bucket = new THREE.Group();
      excavator.bucket.position.set(0, -3.2, 0);
      excavator.arm.add(excavator.bucket);

      const bucketBody = new THREE.Mesh(
        new THREE.BoxGeometry(1.4, 0.8, 0.8),
        new THREE.MeshStandardMaterial({
          color: 0x222222,
          roughness: 0.8,
        })
      );
      bucketBody.position.set(0.7, -0.3, 0);
      bucketBody.castShadow = true;
      excavator.bucket.add(bucketBody);

      const toothGeo = new THREE.BoxGeometry(0.2, 0.4, 0.1);
      const toothMat = new THREE.MeshStandardMaterial({
        color: 0x999999,
        roughness: 0.5,
        metalness: 0.7,
      });
      for (let i = -2; i <= 2; i++) {
        const t = new THREE.Mesh(toothGeo, toothMat);
        t.position.set(1.4, -0.7, (i * 0.8) / 4);
        t.castShadow = true;
        excavator.bucket.add(t);
      }

      // ë²„í‚· ì•ˆ í™
      const dirtGeo = new THREE.BoxGeometry(1.1, 0.6, 0.7);
      const dirtMat = new THREE.MeshStandardMaterial({
        color: 0x5d4037,
        roughness: 1.0,
      });
      excavator.dirtVolume = new THREE.Mesh(dirtGeo, dirtMat);
      excavator.dirtVolume.position.set(0.8, -0.2, 0);
      excavator.dirtVolume.scale.set(0, 0, 0);
      excavator.dirtVolume.castShadow = true;
      excavator.bucket.add(excavator.dirtVolume);

      // ë²„í‚· ë ìœ„ì¹˜ìš©
      excavator.bucketTip = new THREE.Object3D();
      excavator.bucketTip.position.set(1.5, -0.7, 0);
      excavator.bucket.add(excavator.bucketTip);

      // ì»´ë„·í•˜ìš°ìŠ¤ íŒë„¬ (ê³µì¤‘ì— ë–  ìˆê²Œ)
      const cTex = createCnhTexture();
      const cMat = cTex
        ? new THREE.MeshStandardMaterial({
            map: cTex,
            roughness: 0.4,
            metalness: 0.2,
            side: THREE.DoubleSide,
          })
        : new THREE.MeshStandardMaterial({
            color: 0x222222,
            roughness: 0.7,
            metalness: 0.1,
            side: THREE.DoubleSide,
          });
      const cnh = new THREE.Mesh(
        new THREE.PlaneGeometry(3.0, 1.1),
        cMat
      );
      cnh.position.set(0, 4.5, 0);
      cnh.castShadow = true;
      excavator.body.add(cnh);
      excavator.cnhPlate = cnh;

      // ì´ˆê¸° ê°ë„
      excavator.boom.rotation.x = excavator.boomAng;
      excavator.arm.rotation.x = excavator.armAng;
      excavator.bucket.rotation.x = excavator.bucketAng;

      // ì‹œì‘ ìœ„ì¹˜
      excavator.group.position.set(0, 0, 0);
    }

    /* ================== ìœ í‹¸ ================== */
    function spawnParticle(pos, type) {
      const geo = new THREE.PlaneGeometry(
        0.25 + Math.random() * 0.2,
        0.25 + Math.random() * 0.2
      );
      const mat =
        type === "dust"
          ? new THREE.MeshBasicMaterial({
              color: 0xd7ccc8,
              transparent: true,
              opacity: 0.4,
              depthWrite: false,
            })
          : new THREE.MeshStandardMaterial({
              color: 0x5d4037,
              roughness: 0.9,
            });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.copy(pos);
      mesh.position.x += (Math.random() - 0.5) * 0.4;
      mesh.position.z += (Math.random() - 0.5) * 0.4;
      mesh.lookAt(camera.position);
      scene.add(mesh);
      particles.push({
        mesh,
        life: 1,
        vel: new THREE.Vector3(
          (Math.random() - 0.5) * 0.08,
          0.06 + Math.random() * 0.04,
          (Math.random() - 0.5) * 0.08
        ),
      });
    }

    function updateMission() {
      const titleEl = document.getElementById("mission-title");
      const textEl = document.getElementById("mission-text");
      if (currentMissionIdx >= missions.length) {
        if (titleEl) titleEl.innerText = "MISSION";
        if (textEl) textEl.innerText = "ììœ  ì‘ì—… ëª¨ë“œ!";
        return;
      }
      const m = missions[currentMissionIdx];
      if (titleEl) titleEl.innerText = "MISSION " + m.id;
      if (textEl) textEl.innerText = m.text;
      if (m.check()) m.progress += 0.05;
      if (m.progress >= 1 && !m.complete) {
        m.complete = true;
        soundMgr.playComplete();
        currentMissionIdx++;
      }
    }

    function updateExcavator() {
      // ì£¼í–‰
      if (Math.abs(inputs.fwd) > 0.1 || Math.abs(inputs.turn) > 0.1) {
        const spd = inputs.fwd * SPEED.move;
        const rot = inputs.turn * SPEED.turn;
        excavator.group.rotation.y += rot;
        excavator.group.position.x +=
          Math.cos(excavator.group.rotation.y) * spd;
        excavator.group.position.z -=
          Math.sin(excavator.group.rotation.y) * spd;
      }
      // ë•… ì†ì— ì•ˆ íŒŒë¬»íˆê²Œ ê³ ì •
      excavator.group.position.y = 0;

      // ìƒë¶€ íšŒì „
      if (inputs.rot) excavator.body.rotation.y += inputs.rot * SPEED.turn;

      // ë¶ / ì•” / ë²„í‚·
      if (inputs.boom) excavator.boomAng += inputs.boom * SPEED.joint;
      if (inputs.arm) excavator.armAng += inputs.arm * SPEED.joint;
      if (inputs.bucket) excavator.bucketAng += inputs.bucket * SPEED.joint;

      // ê°ë„ ì œí•œ (ë²„í‚· ì•½ 100ë„ ì •ë„)
      excavator.boomAng = THREE.MathUtils.clamp(
        excavator.boomAng,
        -0.1,
        1.8
      );
      excavator.armAng = THREE.MathUtils.clamp(
        excavator.armAng,
        -2.5,
        -0.1
      );
      excavator.bucketAng = THREE.MathUtils.clamp(
        excavator.bucketAng,
        -0.2,
        1.5
      );

      excavator.boom.rotation.x = excavator.boomAng;
      excavator.arm.rotation.x = excavator.armAng;
      excavator.bucket.rotation.x = excavator.bucketAng;

      // ë²„í‚· ë ìœ„ì¹˜ + ì´ì „ ìœ„ì¹˜
      const tipWorld = new THREE.Vector3();
      excavator.bucketTip.getWorldPosition(tipWorld);

      if (!lastTipWorld) {
        lastTipWorld = tipWorld.clone();
      }
      const prevTipWorld = lastTipWorld.clone();
      lastTipWorld.copy(tipWorld);

      // ì§€ë©´ í„°ì¹˜ íŒì •
      const touching = tipWorld.y <= 0.15;

      // F: ë•…íŒŒê¸°
      if (touching && inputs.bucket > 0) {
        gameState.hasDug = true;
        if (gameState.dirtLoad < 1) {
          gameState.dirtLoad += 0.005;

          // ë²„í‚·ì´ ì§€ë‚˜ê°„ ì„  ì „ì²´ë¥¼ ë”°ë¼ ê³¨ íŒŒê¸°
          deformGroundAlongSegment(
            prevTipWorld,
            tipWorld,
            -0.06, // íŒŒê¸° ê°•ë„
            5,     // ìŠ¤í… ìˆ˜
            1.1,   // ë°˜ê²½
            0.6    // ìœ„ë¡œ ì˜¬ë¼ê°ˆ ìˆ˜ ìˆëŠ” ìµœëŒ€ ë†’ì´
          );

          soundMgr.playDig();
          for (let i = 0; i < 4; i++) {
            spawnParticle(tipWorld, "dust");
          }
        }
      }

      // R: ë¤í”„
      if (inputs.bucket < 0 && gameState.dirtLoad > 0) {
        gameState.hasDumped = true;
        gameState.dirtLoad -= 0.01;

        // ì´ë™ ê²½ë¡œë¥¼ ë”°ë¼ í™ ìŒ“ì´ê²Œ
        deformGroundAlongSegment(
          prevTipWorld,
          tipWorld,
          0.18, // ìŒ“ì´ëŠ” ê°•ë„
          5,
          1.4,
          1.8
        );

        for (let i = 0; i < 3; i++) {
          spawnParticle(tipWorld, "dirt");
        }
        for (let i = 0; i < 2; i++) {
          spawnParticle(tipWorld, "dust");
        }
      }

      // ë²„í‚· ì•ˆ í™
      if (excavator.dirtVolume) {
        const s = gameState.dirtLoad;
        excavator.dirtVolume.scale.set(s, s, s);
        excavator.dirtVolume.visible = s > 0.05;
      }

      // ê²Œì´ì§€
      const fill = document.getElementById("load-fill");
      if (fill) fill.style.height = gameState.dirtLoad * 100 + "%";

      const active = Object.values(inputs).some((v) => v !== 0);
      soundMgr.setRPM(active, touching && inputs.bucket > 0);
    }

    function resetGame() {
      for (const k in inputs) inputs[k] = 0;
      gameState.dirtLoad = 0;
      gameState.hasDug = false;
      gameState.hasDumped = false;
      currentMissionIdx = 0;
      missions.forEach((m) => {
        m.complete = false;
        m.progress = 0;
      });
      const fill = document.getElementById("load-fill");
      if (fill) fill.style.height = "0%";
      const t1 = document.getElementById("mission-title");
      const t2 = document.getElementById("mission-text");
      if (t1) t1.innerText = "MISSION 1";
      if (t2) t2.innerText = missions[0].text;

      excavator.group.position.set(0, 0, 0);
      excavator.group.rotation.set(0, 0, 0);
      excavator.body.rotation.set(0, 0, 0);
      excavator.boomAng = 0.3;
      excavator.armAng = -1.7;
      excavator.bucketAng = 0.4;
      excavator.boom.rotation.x = excavator.boomAng;
      excavator.arm.rotation.x = excavator.armAng;
      excavator.bucket.rotation.x = excavator.bucketAng;

      if (excavator.dirtVolume) {
        excavator.dirtVolume.scale.set(0, 0, 0);
        excavator.dirtVolume.visible = false;
      }

      lastTipWorld = null;

      particles.forEach((p) => scene.remove(p.mesh));
      particles.length = 0;

      orbit.radius = 22;
      orbit.theta = Math.PI / 4;
      orbit.phi = Math.PI / 4;
      orbit.target.set(
        excavator.group.position.x,
        excavator.group.position.y + 1.5,
        excavator.group.position.z
      );
      updateCameraOrbit();
    }

    /* ================== ì…ë ¥/UI ================== */
    function setupInput() {
      const onKey = (e, v) => {
        switch (e.code) {
          case "ArrowUp":
            inputs.fwd = v;
            break;
          case "ArrowDown":
            inputs.fwd = -v;
            break;
          case "ArrowLeft":
            inputs.turn = v;
            break;
          case "ArrowRight":
            inputs.turn = -v;
            break;
          case "KeyW":
            inputs.boom = v;
            break;
          case "KeyS":
            inputs.boom = -v;
            break;
          case "KeyE":
            inputs.arm = v;
            break;
          case "KeyQ":
            inputs.arm = -v;
            break;
          case "KeyF":
            inputs.bucket = v;
            break;
          case "KeyR":
            inputs.bucket = -v;
            break;
          case "KeyA":
            inputs.rot = v;
            break;
          case "KeyD":
            inputs.rot = -v;
            break;
        }
      };
      window.addEventListener("keydown", (e) => onKey(e, 1));
      window.addEventListener("keyup", (e) => onKey(e, 0));

      const bind = (id, key, val) => {
        const b = document.getElementById(id);
        if (!b) return;
        const set = (v) => {
          inputs[key] = v;
        };
        b.addEventListener("mousedown", () => set(val));
        b.addEventListener("mouseup", () => set(0));
        b.addEventListener("mouseleave", () => set(0));
        b.addEventListener("touchstart", (e) => {
          e.preventDefault();
          set(val);
        });
        b.addEventListener("touchend", (e) => {
          e.preventDefault();
          set(0);
        });
      };
      bind("btn-fwd", "fwd", 1);
      bind("btn-back", "fwd", -1);
      bind("btn-left", "turn", 1);
      bind("btn-right", "turn", -1);
      bind("btn-boom-up", "boom", -1);
      bind("btn-boom-down", "boom", 1);
      bind("btn-arm-out", "arm", 1);
      bind("btn-arm-in", "arm", -1);
      bind("btn-bucket-in", "bucket", 1);
      bind("btn-bucket-out", "bucket", -1);
    }

    function setupUI() {
      const startBtn = document.getElementById("start-btn");
      if (startBtn) {
        startBtn.addEventListener("click", () => {
          const ov = document.getElementById("start-overlay");
          if (ov) ov.style.display = "none";
          soundMgr.init();
        });
      }

      const resetBtn = document.getElementById("reset-btn");
      if (resetBtn) resetBtn.addEventListener("click", resetGame);

      const soundBtn = document.getElementById("sound-btn");
      if (soundBtn)
        soundBtn.addEventListener("click", () => soundMgr.toggleMute());

      const guideBtn = document.getElementById("guide-toggle-btn");
      if (guideBtn) {
        guideBtn.addEventListener("click", () => {
          const inst = document.getElementById("instructions");
          if (!inst) return;
          const hide = inst.style.display === "none";
          inst.style.display = hide ? "block" : "none";
          guideBtn.textContent = hide ? "ê°€ì´ë“œ ìˆ¨ê¸°ê¸°" : "ê°€ì´ë“œ ë³´ì´ê¸°";
        });
      }

      // ê³µìœ  ë²„íŠ¼ (ëª¨ë°”ì¼/ì¸ì•±ì—ì„œë„ ë¬´ì¡°ê±´ ë­”ê°€ ëœ¨ê²Œ)
      const shareBtn = document.getElementById("share-btn");
      if (shareBtn) {
        shareBtn.addEventListener("click", async () => {
          const url = window.location.href;
          const title = "REAL EXCAVATOR V48 LITE";
          const text = "REAL EXCAVATOR V48 LITE - í¬í¬ë ˆì¸ ì‹œë®¬ë ˆì´í„°";

          async function fallbackShare() {
            if (navigator.clipboard && window.isSecureContext) {
              try {
                await navigator.clipboard.writeText(url);
                alert("í˜„ì¬ í˜ì´ì§€ ì£¼ì†Œë¥¼ í´ë¦½ë³´ë“œì— ë³µì‚¬í–ˆìŠµë‹ˆë‹¤.");
                return;
              } catch (e) {}
            }
            prompt("ì´ ì£¼ì†Œë¥¼ ë³µì‚¬í•´ì„œ ê³µìœ í•´ ì£¼ì„¸ìš”:", url);
          }

          if (navigator.share) {
            try {
              await navigator.share({ title, text, url });
            } catch (e) {
              await fallbackShare();
            }
          } else {
            await fallbackShare();
          }
        });
      }
    }

    // ì»´ë„·í•˜ìš°ìŠ¤ í´ë¦­ ê°ì§€
    function onCanvasClick(e) {
      if (!excavator.cnhPlate) return;
      const rect = renderer.domElement.getBoundingClientRect();
      const x = (e.clientX - rect.left) / rect.width;
      const y = (e.clientY - rect.top) / rect.height;
      mouse.x = x * 2 - 1;
      mouse.y = -y * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const hit = raycaster.intersectObject(excavator.cnhPlate, true);
      if (hit.length > 0) {
        window.open("http://cnh.bulgukto.or.kr/", "_blank", "noopener");
      }
    }
    function onCanvasClickTouch(e) {
      if (!excavator.cnhPlate || !e.changedTouches[0]) return;
      const t = e.changedTouches[0];
      const rect = renderer.domElement.getBoundingClientRect();
      const x = (t.clientX - rect.left) / rect.width;
      const y = (t.clientY - rect.top) / rect.height;
      mouse.x = x * 2 - 1;
      mouse.y = -y * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const hit = raycaster.intersectObject(excavator.cnhPlate, true);
      if (hit.length > 0) {
        window.open("http://cnh.bulgukto.or.kr/", "_blank", "noopener");
      }
    }

    // ë§ˆìš°ìŠ¤ ë“œë˜ê·¸ë¡œ ì¹´ë©”ë¼ íšŒì „
    function onPointerDown(e) {
      orbit.isDragging = true;
      const point = e.touches ? e.touches[0] : e;
      orbit.lastX = point.clientX;
      orbit.lastY = point.clientY;
    }
    function onPointerMove(e) {
      if (!orbit.isDragging) return;
      const point = e.touches ? e.touches[0] : e;
      const dx = point.clientX - orbit.lastX;
      const dy = point.clientY - orbit.lastY;
      orbit.lastX = point.clientX;
      orbit.lastY = point.clientY;

      orbit.theta -= dx * 0.005;
      orbit.phi -= dy * 0.003;
      const minPhi = 0.2;
      const maxPhi = Math.PI / 2 - 0.1;
      if (orbit.phi < minPhi) orbit.phi = minPhi;
      if (orbit.phi > maxPhi) orbit.phi = maxPhi;
      updateCameraOrbit();
    }
    function onPointerUp() {
      orbit.isDragging = false;
    }

    /* ================== ë£¨í”„ ================== */
    function animate() {
      requestAnimationFrame(animate);
      updateExcavator();
      updateMission();

      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life -= 0.02;

        // ì¤‘ë ¥ + ê°ì†
        p.vel.y -= 0.003;
        p.vel.x *= 0.99;
        p.vel.z *= 0.99;

        p.mesh.position.add(p.vel);
        p.mesh.lookAt(camera.position);
        p.mesh.material.opacity = p.life * 0.5;
        if (p.life <= 0) {
          scene.remove(p.mesh);
          particles.splice(i, 1);
        }
      }

      orbit.target.set(
        excavator.group.position.x,
        excavator.group.position.y + 1.5,
        excavator.group.position.z
      );
      updateCameraOrbit();

      renderer.render(scene, camera);
    }

    /* ================== ì´ˆê¸°í™” ================== */
    function init() {
      if (typeof THREE === "undefined") {
        alert(
          "three.js ë¡œë”©ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.\nê´‘ê³  ì°¨ë‹¨ì´ë‚˜ ë„¤íŠ¸ì›Œí¬(https://cdn.jsdelivr.net)ë¥¼ í™•ì¸í•´ ì£¼ì„¸ìš”."
        );
        return;
      }

      const container = document.getElementById("canvas-container");
      const parent = document.getElementById("excavator-wrapper");
      const w = parent.clientWidth || window.innerWidth;
      const h = parent.clientHeight || window.innerHeight;

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);

      camera = new THREE.PerspectiveCamera(55, w / h, 0.1, 300);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(w, h);
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      container.appendChild(renderer.domElement);

      const amb = new THREE.HemisphereLight(0xffffff, 0x555555, 0.7);
      scene.add(amb);
      const sun = new THREE.DirectionalLight(0xfffae0, 1.3);
      sun.position.set(30, 50, 20);
      sun.castShadow = true;
      sun.shadow.mapSize.set(2048, 2048);
      sun.shadow.camera.left = -40;
      sun.shadow.camera.right = 40;
      sun.shadow.camera.top = 40;
      sun.shadow.camera.bottom = -40;
      scene.add(sun);

      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();

      renderer.domElement.addEventListener("click", onCanvasClick);
      renderer.domElement.addEventListener("touchend", onCanvasClickTouch);

      renderer.domElement.addEventListener("mousedown", onPointerDown);
      window.addEventListener("mousemove", onPointerMove);
      window.addEventListener("mouseup", onPointerUp);
      renderer.domElement.addEventListener("touchstart", onPointerDown, {
        passive: false,
      });
      window.addEventListener("touchmove", onPointerMove, { passive: false });
      window.addEventListener("touchend", onPointerUp);

      createGround();
      createEnvironment();
      buildExcavator();
      setupInput();
      setupUI();

      orbit.radius = 22;
      orbit.theta = Math.PI / 4;
      orbit.phi = Math.PI / 4;
      orbit.target.set(
        excavator.group.position.x,
        excavator.group.position.y + 1.5,
        excavator.group.position.z
      );
      updateCameraOrbit();

      window.addEventListener("resize", () => {
        const parent = document.getElementById("excavator-wrapper");
        const w = parent.clientWidth || window.innerWidth;
        const h = parent.clientHeight || window.innerHeight;
        renderer.setSize(w, h);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        updateCameraOrbit();
      });

      animate();
    }

    if (
      document.readyState === "complete" ||
      document.readyState === "interactive"
    ) {
      init();
    } else {
      document.addEventListener("DOMContentLoaded", init);
    }
  </script>
</body>
</html>

